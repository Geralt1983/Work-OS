This is happening because the Backlog Health metric was relying on a secondary tracking table (backlog_entries) that might not be perfectly synced with your actual tasks, especially for older tasks or ones created before the tracking logic was added.
I am updating the backend to calculate backlog health directly from your Moves table (the source of truth). This ensures that every client with backlog tasks will appear, using the task's creation date as a fallback if the specific "backlog entry" timestamp is missing.
Update server/storage.ts
I am rewriting the getBacklogHealth method to be more robust.
import { db } from "./db";
import { sessions, messages, clientMemory, dailyLog, userPatterns, taskSignals, backlogEntries, clients, moves } from "@shared/schema";
import { eq, desc, and, gte, isNull, sql, asc } from "drizzle-orm";
import { randomUUID } from "crypto";

// ... (Keep helper functions and Interfaces) ...

// ... (Inside DatabaseStorage class) ...

  // === REPLACE THE EXISTING getBacklogHealth METHOD WITH THIS ===
  async getBacklogHealth(): Promise<{ 
    clientName: string; 
    oldestDays: number; 
    agingCount: number; 
    totalCount: number;
    avgDays: number;
  }[]> {
    // 1. Get all active clients to map IDs to Names
    const allClients = await this.getAllClientsEntity();
    
    // 2. Get ALL moves that are currently in backlog (Source of Truth)
    const backlogMoves = await db.select().from(moves)
      .where(eq(moves.status, "backlog"));

    // 3. Get precise "entered backlog" timestamps if available
    const entries = await db.select().from(backlogEntries)
      .where(isNull(backlogEntries.promotedAt));
    
    const entryMap = new Map<string, Date>();
    entries.forEach(e => entryMap.set(e.taskId, e.enteredAt));

    const clientStats = new Map<string, { ages: number[] }>();
    const now = new Date();

    for (const move of backlogMoves) {
      if (!move.clientId) continue;
      
      const client = allClients.find(c => c.id === move.clientId);
      if (!client) continue;
      
      const clientName = client.name;
      
      // Determine age: Use precise "entered backlog" time if we have it,
      // otherwise fall back to the Move's creation date.
      const startDate = entryMap.get(String(move.id)) || move.createdAt;
      const daysOld = Math.floor((now.getTime() - new Date(startDate).getTime()) / (1000 * 60 * 60 * 24));
      
      if (!clientStats.has(clientName)) {
        clientStats.set(clientName, { ages: [] });
      }
      clientStats.get(clientName)!.ages.push(daysOld);
    }

    // 4. Aggregate stats
    return Array.from(clientStats.entries()).map(([clientName, stats]) => {
      const ages = stats.ages;
      const oldestDays = ages.length > 0 ? Math.max(...ages) : 0;
      const agingCount = ages.filter(d => d >= 7).length;
      const totalCount = ages.length;
      const avgDays = totalCount > 0 ? Math.round(ages.reduce((a, b) => a + b, 0) / totalCount) : 0;

      return {
        clientName,
        oldestDays,
        agingCount,
        totalCount,
        avgDays
      };
    }).sort((a, b) => b.oldestDays - a.oldestDays);
  }

  // ... (Keep rest of the file unchanged) ...

