That is a fantastic idea. A "Momentum Graph" perfectly fits the philosophy of Work OSâ€”it's not just about what you did, it's about your velocity.
We can implement this by comparing your Current Week vs. Previous Week.
The Plan: "Velocity Tracking"
 * Backend (server/storage.ts): Update getWeeklyMetrics to look back 14 days instead of 7. It will calculate a "Momentum Score" (percentage change).
 * Frontend (client/src/pages/Metrics.tsx): Add a "Velocity Indicator" to the Weekly Trends card.
   * ðŸš€ Accelerating: You are doing more than last week.
   * âš“ Steady: You are maintaining pace.
   * ðŸ§Š Cooling: You are slowing down (might need a break or smaller moves).
Here are the files to update.
1. Update server/storage.ts
This adds the logic to compare the last 7 days against the 7 days before that.
import { db } from "./db";
import { sessions, messages, clientMemory, dailyLog, userPatterns, taskSignals, backlogEntries, clients, moves } from "@shared/schema";
import { eq, desc, and, gte, isNull, sql, asc } from "drizzle-orm";
import { randomUUID } from "crypto";

export function getLocalDateString(date: Date = new Date()): string {
  const options: Intl.DateTimeFormatOptions = {
    timeZone: 'America/New_York',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  };
  const parts = new Intl.DateTimeFormat('en-CA', options).formatToParts(date);
  const year = parts.find(p => p.type === 'year')?.value;
  const month = parts.find(p => p.type === 'month')?.value;
  const day = parts.find(p => p.type === 'day')?.value;
  return `${year}-${month}-${day}`;
}

// ... (Keep all existing interfaces and IStorage definition) ...
// Just replace the DatabaseStorage class implementation for getWeeklyMetrics below

import type { 
  Session, InsertSession, 
  Message, InsertMessage,
  ClientMemory, InsertClientMemory,
  DailyLog, InsertDailyLog,
  UserPattern, InsertUserPattern,
  TaskSignal, InsertTaskSignal,
  BacklogEntry, InsertBacklogEntry,
  Client, InsertClient,
  Move, InsertMove,
  MoveStatus
} from "@shared/schema";

// ... (Keep IStorage interface same as before) ...

class DatabaseStorage {
  // ... (Keep all other methods: createSession, getSession, etc.) ...

  // ... (Keep getWeeklyLogs same as before) ...
  async getWeeklyLogs(days: number = 7): Promise<DailyLog[]> {
    const logs = await db.select().from(dailyLog)
      .orderBy(desc(dailyLog.date))
      .limit(days);
    return logs;
  }

  // === UPDATE THIS FUNCTION ===
  async getWeeklyMetrics(): Promise<{
    days: Array<{
      date: string;
      movesCompleted: number;
      estimatedMinutes: number;
      pacingPercent: number;
    }>;
    averageMovesPerDay: number;
    totalMoves: number;
    totalMinutes: number;
    momentum: {
      trend: "up" | "down" | "stable";
      percentChange: number;
      message: string;
    };
  }> {
    // Fetch 14 days to compare this week vs last week
    const logs = await this.getWeeklyLogs(14);
    const targetMinutes = 180;
    
    const logsByDate = new Map<string, DailyLog>();
    for (const log of logs) {
      logsByDate.set(log.date, log);
    }
    
    const days: Array<{
      date: string;
      movesCompleted: number;
      estimatedMinutes: number;
      pacingPercent: number;
    }> = [];
    
    let currentWeekMoves = 0;
    let previousWeekMoves = 0;
    const today = new Date();

    // Calculate Current Week (Last 7 days including today)
    for (let i = 6; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = getLocalDateString(date);
      
      const log = logsByDate.get(dateStr);
      const completedMoves = log ? (log.completedMoves as unknown as string[] || []) : [];
      const movesCompleted = completedMoves.length;
      currentWeekMoves += movesCompleted;

      const estimatedMinutes = movesCompleted * 20;
      const pacingPercent = targetMinutes > 0 
        ? Math.min(Math.round((estimatedMinutes / targetMinutes) * 100), 100)
        : 0;
      
      days.push({
        date: dateStr,
        movesCompleted,
        estimatedMinutes,
        pacingPercent,
      });
    }

    // Calculate Previous Week (Days 8-14)
    for (let i = 13; i >= 7; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = getLocalDateString(date);
      const log = logsByDate.get(dateStr);
      const movesCompleted = log ? (log.completedMoves as unknown as string[] || []).length : 0;
      previousWeekMoves += movesCompleted;
    }

    // Calculate Momentum
    let trend: "up" | "down" | "stable" = "stable";
    let percentChange = 0;
    let message = "Steady flow";

    if (previousWeekMoves === 0) {
        if (currentWeekMoves > 0) {
            trend = "up";
            percentChange = 100;
            message = "Building momentum";
        }
    } else {
        const rawChange = ((currentWeekMoves - previousWeekMoves) / previousWeekMoves) * 100;
        percentChange = Math.round(Math.abs(rawChange));
        
        if (rawChange >= 10) {
            trend = "up";
            message = "Accelerating";
        } else if (rawChange <= -10) {
            trend = "down";
            message = "Cooling down";
        }
    }
    
    const totalMoves = currentWeekMoves;
    const totalMinutes = totalMoves * 20;
    const daysWithData = days.filter(d => d.movesCompleted > 0).length;
    const averageMovesPerDay = daysWithData > 0 ? Math.round(totalMoves / daysWithData) : 0;
    
    return {
      days,
      averageMovesPerDay,
      totalMoves,
      totalMinutes,
      momentum: {
        trend,
        percentChange,
        message
      }
    };
  }

  // ... (Rest of the class methods remain the same) ...
  // ... (Keep getClientMetrics, getDrainTypeMetrics, etc.) ...
  async getTodayMetrics() { /* ... copy existing ... */ return { date: "", movesCompleted: 0, estimatedMinutes: 0, targetMinutes: 0, pacingPercent: 0, clientsTouched: [], backlogMoves: 0, nonBacklogMoves: 0 }; } // Placeholder to save space, keep original
  async getClientMetrics() { return []; } // Placeholder
  async getDrainTypeMetrics(daysBack: number = 30) { return []; } // Placeholder
  async getProductivityByHour() { return []; } // Placeholder
  async getBacklogHealth() { return []; } // Placeholder
  async getAvoidedTasks(daysBack: number = 14) { return []; } // Placeholder
  async getPatterns(patternType?: string) { return []; } // Placeholder
  // ... (All other methods) ...
}

// Important: Since I cannot paste the whole file, just replace the getWeeklyMetrics function 
// in your existing server/storage.ts with the new version above.
// You don't need to change anything else.

export const storage = new DatabaseStorage();

2. Update client/src/pages/Metrics.tsx
This adds the "Velocity" badge to the UI.
// ... (Imports remain the same) ...
import { 
  Clock, Target, TrendingUp, Users, AlertCircle, CheckCircle2, 
  Brain, MessageCircle, FileText, Lightbulb, Zap, Archive, 
  ThumbsUp, ThumbsDown, Minus, AlertTriangle, Star, Loader2,
  ArrowUpRight, ArrowDownRight, Activity // Add these new icons
} from "lucide-react";
// ... (Rest of imports) ...

// Update interface
interface WeeklyMetrics {
  days: Array<{
    date: string;
    movesCompleted: number;
    estimatedMinutes: number;
    pacingPercent: number;
  }>;
  averageMovesPerDay: number;
  totalMoves: number;
  totalMinutes: number;
  // Add momentum
  momentum: {
    trend: "up" | "down" | "stable";
    percentChange: number;
    message: string;
  };
}

// ... (Rest of interfaces and constants remain the same) ...

export default function Metrics() {
  // ... (Hooks remain the same) ...

  // ... (Helper functions remain the same) ...

  // === UPDATE THIS SECTION IN MetricsContent ===
  const MetricsContent = (
    <div className="space-y-6 w-full overflow-x-hidden">
      
      {/* Today's Pacing (Keep as is) */}
      {/* ... */}

      {/* Weekly Trends - NOW WITH MOMENTUM */}
      <ArcCard glowColor="cyan" className="w-full">
        <div className="p-5 sm:p-6">
          <div className="flex items-center justify-between pb-6">
            <div className="flex flex-col">
                <div className="text-lg font-semibold flex items-center gap-2 text-white">
                    <TrendingUp className="h-5 w-5 text-cyan-400" />
                    Weekly Trends
                </div>
                {/* MOMENTUM INDICATOR */}
                {weeklyMetrics && (
                    <div className="flex items-center gap-2 mt-1">
                        {weeklyMetrics.momentum.trend === "up" && (
                            <span className="flex items-center gap-1 text-xs font-bold text-emerald-400">
                                <ArrowUpRight className="w-3 h-3" /> {weeklyMetrics.momentum.percentChange}% {weeklyMetrics.momentum.message}
                            </span>
                        )}
                        {weeklyMetrics.momentum.trend === "down" && (
                            <span className="flex items-center gap-1 text-xs font-bold text-rose-400">
                                <ArrowDownRight className="w-3 h-3" /> {weeklyMetrics.momentum.percentChange}% {weeklyMetrics.momentum.message}
                            </span>
                        )}
                        {weeklyMetrics.momentum.trend === "stable" && (
                            <span className="flex items-center gap-1 text-xs font-bold text-cyan-400">
                                <Activity className="w-3 h-3" /> {weeklyMetrics.momentum.message}
                            </span>
                        )}
                    </div>
                )}
            </div>
            <Badge className="bg-cyan-500/20 text-cyan-300 border-cyan-500/30">
              {weeklyHours}h / 15h
            </Badge>
          </div>

          {/* ... (Rest of the Weekly Trends chart remains the same) ... */}
          {loadingWeekly ? (
            <Skeleton className="h-40 w-full bg-white/5" />
          ) : weeklyMetrics ? (
            <div className="space-y-5">
              {/* List of Days */}
              <div className="space-y-3">
                {weeklyMetrics.days.map((day) => {
                  // ... (Keep existing map logic) ...
                  const dailyHours = (day.estimatedMinutes / 60).toFixed(1);
                  const isZero = day.estimatedMinutes === 0;
                  const dayName = new Date(day.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long' });
                  const percent = Math.min((day.estimatedMinutes / 180) * 100, 100);

                  return (
                    <div key={day.date} className="flex items-center gap-4">
                      <div className="w-24 shrink-0 text-sm text-slate-300 font-medium truncate">
                        {dayName}
                      </div>
                      <div className="flex-1 h-2.5 bg-black/40 rounded-full overflow-hidden relative">
                        <div 
                          className={`h-full rounded-full transition-all duration-500 ${isZero ? 'bg-transparent' : 'bg-cyan-500'}`}
                          style={{ width: `${percent}%` }}
                        />
                      </div>
                      <div className={`w-10 shrink-0 text-right text-sm font-bold ${isZero ? 'text-white/20' : 'text-cyan-300'}`}>
                        {dailyHours}h
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* ... (Keep Stats Footer) ... */}
            </div>
          ) : <p className="text-muted-foreground">No data</p>}
        </div>
      </ArcCard>

      {/* ... (Rest of components) ... */}
    </div>
  );

  // ... (Return statement remains the same) ...
}

