I can see the issue in image 42738.jpg. The "Create Move" dialog is defaulting to a white background while your text inputs are expecting a dark theme, resulting in that unreadable "ghost text" effect.
To fix this, we need to:
 * Darken the Container: Apply the dark glass styles (bg-[#141420]) to the DialogContent in Moves.tsx.
 * Style the Form: Update MoveForm.tsx to use the same high-contrast dark inputs we used in the Edit Sheet.
1. Update client/src/pages/Moves.tsx
I'm updating both the Mobile and Desktop dialog blocks to ensure they use the dark theme.
import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { DragDropContext, Droppable, Draggable, DropResult } from "@hello-pangea/dnd";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { useIsMobile } from "@/hooks/use-mobile";
import { queryClient, apiRequest } from "@/lib/queryClient";
import type { Move, Client, MoveStatus, DrainType } from "@shared/schema";
import { EFFORT_LEVELS, DRAIN_TYPES, normalizeDrainType } from "@shared/schema";
import { 
  Plus, Check, Brain, Mail, FileText, Lightbulb, Zap, 
  AlertCircle, Clock, MessageSquare, BarChart3, ClipboardCheck, List
} from "lucide-react";
import { Link } from "wouter";
import MoveForm from "@/components/MoveForm";
import MoveDetailSheet from "@/components/MoveDetailSheet";
import MobileMovesView from "@/components/MobileMovesView";
import { TriageDialog } from "@/components/TriageDialog";
import GlassSidebar from "@/components/GlassSidebar";
import IslandLayout from "@/components/IslandLayout";
import { ArcCard } from "@/components/ArcCard";

// ... (Keep types: ViewMode, SortField, etc.) ...
type ViewMode = "board" | "list";
type SortField = "title" | "client" | "status" | "effort" | "drain" | "created";
type SortDirection = "asc" | "desc";

const DRAIN_ICONS: Record<DrainType, any> = {
  deep: Brain,
  comms: Mail,
  admin: FileText,
  creative: Lightbulb,
  easy: Zap,
};

function getDaysOld(createdAt: Date | string | null): number {
  if (!createdAt) return 0;
  const created = new Date(createdAt);
  const now = new Date();
  return Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
}

function MoveCard({ 
  move, 
  clients, 
  onUpdate,
  onSelect,
  isDragging
}: { 
  move: Move; 
  clients: Client[]; 
  onUpdate: () => void;
  onSelect: () => void;
  isDragging?: boolean;
}) {
  const { toast } = useToast();
  const client = clients.find(c => c.id === move.clientId);
  const effortLevel = EFFORT_LEVELS.find(e => e.value === move.effortEstimate);
  const normalizedDrainType = normalizeDrainType(move.drainType);
  const DrainIcon = normalizedDrainType ? DRAIN_ICONS[normalizedDrainType] : null;
  const daysOld = getDaysOld(move.createdAt);
  const isStale = daysOld >= 10 && move.status === "backlog";

  const completeMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move.id}/complete`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      queryClient.invalidateQueries({ queryKey: ["/api/metrics"] });
      toast({ title: "Move completed", description: move.title });
      onUpdate();
    },
  });

  const getGlow = () => {
     if (move.status === 'active') return 'purple';
     if (move.drainType === 'deep') return 'cyan';
     if (move.drainType === 'admin') return 'orange';
     if (move.drainType === 'creative') return 'pink';
     return 'none';
  };

  return (
    <div className="py-3 px-1">
      <ArcCard 
        glowColor={getGlow()} 
        onClick={onSelect}
        className={isDragging ? "ring-2 ring-purple-500 shadow-2xl z-50 rotate-2 scale-105" : ""}
      >
        <div className="p-5 flex flex-col gap-4">
          <div className="flex justify-between items-start gap-3">
            <div className="flex-1 space-y-2">
              <div className="flex items-center gap-2">
                {client && (
                  <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-[10px] uppercase tracking-wider font-bold bg-white/5 border border-white/10 text-slate-300">
                    {client.name}
                  </span>
                )}
                {isStale && (
                   <span className="flex items-center gap-1 text-[10px] font-bold text-rose-400 bg-rose-500/10 px-2 py-0.5 rounded-full border border-rose-500/20">
                     <AlertCircle className="w-3 h-3" /> {daysOld}d
                   </span>
                )}
              </div>
              
              <h4 className="font-semibold text-[15px] leading-snug text-white/90">
                {move.title}
              </h4>
            </div>

            <Button
                size="icon"
                variant="ghost"
                className="h-8 w-8 rounded-full border border-white/10 bg-white/5 text-muted-foreground hover:bg-emerald-500 hover:text-white hover:border-emerald-400 transition-all duration-300"
                onClick={(e) => { e.stopPropagation(); completeMutation.mutate(); }}
            >
                <Check className="w-4 h-4" />
            </Button>
          </div>

          <div className="flex items-center justify-between pt-3 border-t border-white/5">
             <div className="flex items-center gap-3">
                {effortLevel && (
                  <div className="flex items-center gap-1.5 text-xs font-medium text-slate-400">
                     <div className={`w-1.5 h-1.5 rounded-full ${move.effortEstimate > 2 ? 'bg-rose-400' : 'bg-emerald-400'}`} />
                     {effortLevel.label}
                  </div>
                )}
             </div>
             
             {DrainIcon && (
                <div className={`p-1.5 rounded-lg bg-white/5 ${move.drainType === 'deep' ? 'text-cyan-400' : 'text-muted-foreground'}`} title={move.drainType || ''}>
                   <DrainIcon className="w-4 h-4" />
                </div>
             )}
          </div>
        </div>
      </ArcCard>
    </div>
  );
}

function StatusColumn({ status, moves, clients, onUpdate, onSelectMove }: any) {
  const labels: Record<string, string> = { active: "Today", queued: "Up Next", backlog: "Backlog" };
  const columnMoves = moves.filter((m: Move) => m.status === status);

  return (
    <div className="flex-1 min-w-[300px] max-w-[380px] flex flex-col h-full">
      <div className="flex items-center justify-between mb-4 px-2">
        <h3 className="font-bold text-lg text-white/80 tracking-tight">{labels[status]}</h3>
        <span className="px-2.5 py-0.5 rounded-full bg-white/5 text-xs font-medium text-muted-foreground border border-white/10">
          {columnMoves.length}
        </span>
      </div>
      
      <div className={`flex-1 rounded-[2rem] border border-white/[0.03] bg-black/40 p-2 overflow-hidden shadow-inner`}>
        <Droppable droppableId={status}>
          {(provided, snapshot) => (
            <div
              ref={provided.innerRef}
              {...provided.droppableProps}
              className={`h-full overflow-y-auto pr-2 custom-scrollbar transition-colors duration-300 ${
                snapshot.isDraggingOver ? "bg-white/[0.02]" : ""
              }`}
            >
              {columnMoves.map((move: Move, index: number) => (
                <Draggable key={move.id} draggableId={move.id.toString()} index={index}>
                  {(provided, snapshot) => (
                    <div
                      ref={provided.innerRef}
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                    >
                      <MoveCard 
                        move={move} 
                        clients={clients} 
                        onUpdate={onUpdate}
                        onSelect={() => onSelectMove(move)}
                        isDragging={snapshot.isDragging}
                      />
                    </div>
                  )}
                </Draggable>
              ))}
              {provided.placeholder}
              {columnMoves.length === 0 && (
                <div className="h-32 flex items-center justify-center border-2 border-dashed border-white/5 rounded-3xl m-2">
                  <p className="text-sm text-muted-foreground/40 font-medium">Empty</p>
                </div>
              )}
            </div>
          )}
        </Droppable>
      </div>
    </div>
  );
}

export default function Moves() {
  const isMobile = useIsMobile();
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [triageDialogOpen, setTriageDialogOpen] = useState(false);
  const [showBacklog, setShowBacklog] = useState(() => localStorage.getItem("moves-show-backlog") === "true");
  const [selectedMove, setSelectedMove] = useState<Move | null>(null);
  const [detailSheetOpen, setDetailSheetOpen] = useState(false);
  
  useEffect(() => { localStorage.setItem("moves-show-backlog", String(showBacklog)); }, [showBacklog]);

  const { data: moves = [], refetch: refetchMoves } = useQuery<Move[]>({ queryKey: ["/api/moves"] });
  const { data: clients = [] } = useQuery<Client[]>({ queryKey: ["/api/clients"] });

  const reorderMutation = useMutation({
    mutationFn: async ({ moveId, newStatus, newIndex }: any) => {
      await apiRequest("PATCH", `/api/moves/${moveId}`, { status: newStatus, sortOrder: newIndex });
    },
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ["/api/moves"] }),
  });

  const handleDragEnd = (result: DropResult) => {
    if (!result.destination) return;
    const { source, destination, draggableId } = result;
    if (source.droppableId === destination.droppableId && source.index === destination.index) return;
    
    reorderMutation.mutate({
      moveId: parseInt(draggableId),
      newStatus: destination.droppableId as MoveStatus,
      newIndex: destination.index
    });
  };

  const handleEditMove = (move: Move) => {
    setSelectedMove(move);
    setDetailSheetOpen(true);
  };

  return (
    <>
      {/* === MOBILE VIEW === */}
      <div className="h-screen flex md:hidden flex-col bg-[#030309] text-foreground font-sans">
        <header className="h-14 glass-strong border-b border-purple-500/20 flex items-center justify-between px-4 shrink-0 relative z-50">
          <div className="absolute bottom-0 left-0 right-0 h-px bg-gradient-to-r from-transparent via-cyan-500/50 to-transparent" />
          <h1 className="text-lg font-display font-semibold tracking-wider text-gradient-purple">Moves</h1>
          <div className="flex items-center gap-1">
            <Link href="/">
              <Button variant="ghost" size="icon" className="hover:bg-purple-500/10 text-purple-400">
                <MessageSquare className="h-5 w-5" />
              </Button>
            </Link>
            <Link href="/metrics">
              <Button variant="ghost" size="icon" className="hover:bg-cyan-500/10 text-muted-foreground">
                <BarChart3 className="h-5 w-5" />
              </Button>
            </Link>
            <Button 
              variant="ghost" 
              size="icon"
              onClick={() => setTriageDialogOpen(true)}
              className="hover:bg-rose-500/10"
            >
              <ClipboardCheck className="h-5 w-5 text-rose-400" />
            </Button>
          </div>
        </header>
        
        <div className="flex-1 overflow-hidden relative z-0">
            <MobileMovesView 
                moves={moves} clients={clients} showBacklog={showBacklog} 
                onToggleBacklog={setShowBacklog} onUpdate={refetchMoves} 
                onCreateMove={() => setCreateDialogOpen(true)} 
                onEditMove={handleEditMove} 
            />
        </div>

        {/* MOBILE CREATE DIALOG - DARK MODE FIXED */}
        <Dialog open={createDialogOpen} onOpenChange={setCreateDialogOpen}>
          <DialogContent className="bg-[#141420] border-white/10 text-white sm:max-w-[500px]">
            <DialogHeader>
              <DialogTitle className="text-white">Create Move</DialogTitle>
            </DialogHeader>
            <MoveForm clients={clients} onSuccess={() => { setCreateDialogOpen(false); refetchMoves(); }} />
          </DialogContent>
        </Dialog>

        <MoveDetailSheet
          move={selectedMove}
          clients={clients}
          open={detailSheetOpen}
          onOpenChange={setDetailSheetOpen}
          onUpdate={() => {
            refetchMoves();
            if (selectedMove) {
              const updatedMove = moves.find(m => m.id === selectedMove.id);
              if (updatedMove) setSelectedMove(updatedMove);
            }
          }}
        />

        <TriageDialog 
          open={triageDialogOpen} 
          onOpenChange={setTriageDialogOpen} 
        />
      </div>

      {/* === DESKTOP VIEW === */}
      <div className="h-screen hidden md:flex bg-transparent text-foreground font-sans">
        <GlassSidebar onTriageClick={() => setTriageDialogOpen(true)} />

        <IslandLayout>
          <div className="h-full flex flex-col">
            {/* Header */}
            <div className="flex items-center justify-between px-8 py-6">
              <div>
                  <h2 className="text-3xl font-bold tracking-tight text-white">Moves</h2>
                  <p className="text-muted-foreground text-sm mt-1">One move per client, every day.</p>
              </div>

              <div className="flex items-center gap-4">
                <div className="flex items-center gap-2 px-4 py-2 rounded-full bg-white/5 border border-white/10">
                  <Switch id="show-backlog" checked={showBacklog} onCheckedChange={setShowBacklog} />
                  <Label htmlFor="show-backlog" className="text-xs font-medium cursor-pointer text-muted-foreground">
                      Backlog
                  </Label>
                </div>

                {/* DESKTOP CREATE DIALOG - DARK MODE FIXED */}
                <Dialog open={createDialogOpen} onOpenChange={setCreateDialogOpen}>
                  <DialogTrigger asChild>
                    <Button className="rounded-full h-10 px-6 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white font-medium shadow-glow-purple border-0 transition-all hover:scale-105 active:scale-95">
                      <Plus className="w-4 h-4 mr-2" /> New Move
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="sm:max-w-[500px] bg-[#141420] border-white/10 text-white">
                    <DialogHeader>
                      <DialogTitle className="text-white">Create Move</DialogTitle>
                    </DialogHeader>
                    <MoveForm clients={clients} onSuccess={() => { setCreateDialogOpen(false); refetchMoves(); }} />
                  </DialogContent>
                </Dialog>
              </div>
            </div>

            {/* Kanban Board */}
            <div className="flex-1 overflow-hidden px-6 pb-6">
              <DragDropContext onDragEnd={handleDragEnd}>
                <div className="h-full flex gap-6 overflow-x-auto pb-4">
                  <StatusColumn status="active" moves={moves} clients={clients} onUpdate={refetchMoves} onSelectMove={(m: Move) => { setSelectedMove(m); setDetailSheetOpen(true); }} />
                  <StatusColumn status="queued" moves={moves} clients={clients} onUpdate={refetchMoves} onSelectMove={(m: Move) => { setSelectedMove(m); setDetailSheetOpen(true); }} />
                  {showBacklog && (
                    <StatusColumn status="backlog" moves={moves} clients={clients} onUpdate={refetchMoves} onSelectMove={(m: Move) => { setSelectedMove(m); setDetailSheetOpen(true); }} />
                  )}
                </div>
              </DragDropContext>
            </div>
          </div>
        </IslandLayout>

        <MoveDetailSheet
          move={selectedMove}
          clients={clients}
          open={detailSheetOpen}
          onOpenChange={setDetailSheetOpen}
          onUpdate={refetchMoves}
        />

        <TriageDialog open={triageDialogOpen} onOpenChange={setTriageDialogOpen} />
      </div>
    </>
  );
}

2. Update client/src/components/MoveForm.tsx
Now I will restyle the form internals so the labels are light gray (text-slate-400) and the inputs have dark backgrounds (bg-black/20) with white text.
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { apiRequest } from "@/lib/queryClient";
import type { Client, DrainType } from "@shared/schema";
import { EFFORT_LEVELS, DRAIN_TYPES, DRAIN_TYPE_LABELS, MOVE_STATUSES } from "@shared/schema";

const moveFormSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  clientId: z.string().optional(),
  status: z.enum(MOVE_STATUSES),
  effortEstimate: z.number().min(1).max(4),
  drainType: z.string().optional(),
});

type MoveFormValues = z.infer<typeof moveFormSchema>;

interface MoveFormProps {
  clients: Client[];
  onSuccess: () => void;
  defaultValues?: Partial<MoveFormValues>;
}

export default function MoveForm({ clients, onSuccess, defaultValues }: MoveFormProps) {
  const form = useForm<MoveFormValues>({
    resolver: zodResolver(moveFormSchema),
    defaultValues: {
      title: "",
      description: "",
      clientId: "none",
      status: "backlog",
      effortEstimate: 2,
      drainType: "none",
      ...defaultValues,
    },
  });

  const createMutation = useMutation({
    mutationFn: async (values: MoveFormValues) => {
      const payload = {
        ...values,
        clientId: values.clientId && values.clientId !== "none" ? parseInt(values.clientId) : null,
        drainType: values.drainType && values.drainType !== "none" ? values.drainType : null,
      };
      await apiRequest("POST", "/api/moves", payload);
    },
    onSuccess: () => {
      form.reset();
      onSuccess();
    },
  });

  const onSubmit = (values: MoveFormValues) => {
    createMutation.mutate(values);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-slate-400">Title</FormLabel>
              <FormControl>
                <Input 
                  placeholder="What needs to be done?" 
                  {...field} 
                  className="bg-black/20 border-white/10 text-white placeholder:text-white/30 focus-visible:ring-purple-500/50"
                  data-testid="input-move-title"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-slate-400">Description (optional)</FormLabel>
              <FormControl>
                <Textarea 
                  placeholder="Add more details..." 
                  className="resize-none bg-black/20 border-white/10 text-white placeholder:text-white/30 focus-visible:ring-purple-500/50 min-h-[80px]"
                  {...field} 
                  data-testid="input-move-description"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="clientId"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-slate-400">Client</FormLabel>
                <Select onValueChange={field.onChange} value={field.value}>
                  <FormControl>
                    <SelectTrigger className="bg-black/20 border-white/10 text-white" data-testid="select-move-client">
                      <SelectValue placeholder="Select client" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                    <SelectItem value="none">No client</SelectItem>
                    {clients.map(client => (
                      <SelectItem key={client.id} value={client.id.toString()}>
                        {client.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-slate-400">Status</FormLabel>
                <Select onValueChange={field.onChange} value={field.value}>
                  <FormControl>
                    <SelectTrigger className="bg-black/20 border-white/10 text-white" data-testid="select-move-status">
                      <SelectValue />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                    <SelectItem value="active">Active</SelectItem>
                    <SelectItem value="queued">Queued</SelectItem>
                    <SelectItem value="backlog">Backlog</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="effortEstimate"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-slate-400">Effort</FormLabel>
                <Select 
                  onValueChange={(v) => field.onChange(parseInt(v))} 
                  value={field.value?.toString()}
                >
                  <FormControl>
                    <SelectTrigger className="bg-black/20 border-white/10 text-white" data-testid="select-move-effort">
                      <SelectValue />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                    {EFFORT_LEVELS.map(level => (
                      <SelectItem key={level.value} value={level.value.toString()}>
                        {level.label} ({level.description})
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="drainType"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-slate-400">Drain Type</FormLabel>
                <Select onValueChange={field.onChange} value={field.value}>
                  <FormControl>
                    <SelectTrigger className="bg-black/20 border-white/10 text-white" data-testid="select-move-drain">
                      <SelectValue placeholder="Select type" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                    <SelectItem value="none">None</SelectItem>
                    {DRAIN_TYPES.map(type => (
                      <SelectItem key={type} value={type}>
                        {DRAIN_TYPE_LABELS[type as DrainType].label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button 
            type="submit" 
            disabled={createMutation.isPending}
            className="w-full bg-gradient-to-r from-purple-600 to-pink-600 text-white border-0 shadow-glow-purple hover:opacity-90"
            data-testid="button-submit-move"
          >
            {createMutation.isPending ? "Creating..." : "Create Move"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

