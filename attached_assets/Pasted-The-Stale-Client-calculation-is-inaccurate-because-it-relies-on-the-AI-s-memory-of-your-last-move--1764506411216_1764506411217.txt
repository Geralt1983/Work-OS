The "Stale Client" calculation is inaccurate because it relies on the AI's memory of your last move (client_memory table), which isn't always perfectly synced with the actual tasks you completed in the Moves table.
I am fixing this by making the Metrics page look at the real completed tasks database directly, so it will always be 100% accurate, even if the AI missed a beat.
1. Update server/storage.ts
I am rewriting getClientMetrics to calculate "Days Since Last Move" by querying your actual completed tasks history, rather than relying on a cached value.
import { db } from "./db";
import { sessions, messages, clientMemory, dailyLog, userPatterns, taskSignals, backlogEntries, clients, moves } from "@shared/schema";
import { eq, desc, and, gte, isNull, sql, asc } from "drizzle-orm";
import { randomUUID } from "crypto";

// ... (Keep getLocalDateString and Interfaces) ...

// ... (Inside DatabaseStorage class) ...

  // === REPLACE EXISTING getClientMetrics WITH THIS ===
  async getClientMetrics(): Promise<Array<{
    clientName: string;
    totalMoves: number;
    lastMoveAt: Date | null;
    daysSinceLastMove: number;
    sentiment: string;
    importance: string;
    tier: string;
  }>> {
    // 1. Get all active clients
    const allClients = await this.getAllClientsEntity();
    
    // 2. Get AI memory (for sentiment/importance/tier metadata only)
    const memories = await this.getAllClients(); 
    const memoryMap = new Map(memories.map(m => [m.clientName.toLowerCase(), m]));
    
    const now = new Date();

    // 3. Calculate metrics from REAL moves data
    const metrics = await Promise.all(allClients.map(async (client) => {
      // Get all completed moves for this client, newest first
      const completedMoves = await db.select().from(moves)
        .where(and(
          eq(moves.clientId, client.id),
          eq(moves.status, "done")
        ))
        .orderBy(desc(moves.completedAt));
        
      const lastMove = completedMoves[0];
      const totalMoves = completedMoves.length;
      
      let daysSinceLastMove = 999;
      if (lastMove?.completedAt) {
        const lastDate = new Date(lastMove.completedAt);
        daysSinceLastMove = Math.floor((now.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
      } else {
        // If no moves ever, use creation date to determine staleness
        const createdDate = new Date(client.createdAt);
        daysSinceLastMove = Math.floor((now.getTime() - createdDate.getTime()) / (1000 * 60 * 60 * 24));
      }
      
      const memory = memoryMap.get(client.name.toLowerCase());
      
      return {
        clientName: client.name,
        totalMoves,
        lastMoveAt: lastMove?.completedAt || null,
        daysSinceLastMove,
        sentiment: memory?.sentiment || "neutral",
        importance: memory?.importance || "medium",
        tier: memory?.tier || "active",
      };
    }));
    
    // Sort by staleness (stale clients at top)
    return metrics.sort((a, b) => b.daysSinceLastMove - a.daysSinceLastMove);
  }

  // ... (Keep rest of file unchanged) ...

2. Update server/routes.ts
I am also adding a "Sync" hook so that when you complete a task, it updates the AI's memory immediately. This ensures the Chat (which uses memory) stays as accurate as the Metrics page.
// ... imports ...

// ... inside app.post("/api/moves/:id/complete") ...

  app.post("/api/moves/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const effortActual = req.body.effortActual ? parseInt(req.body.effortActual) : undefined;
      const move = await storage.completeMove(id, effortActual);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      
      // FIX: Update AI Memory + Daily Metrics
      if (move.clientId) {
        const client = await storage.getClient(move.clientId);
        if (client) {
          const today = getLocalDateString();
          
          // 1. Log to Daily Pacing
          await storage.addCompletedMove(today, {
            moveId: move.id.toString(),
            description: move.title,
            clientName: client.name,
            at: new Date().toISOString(),
            source: "moves-ui",
          });
          
          // 2. Sync to AI Client Memory (so Chat knows you worked on it)
          await storage.updateClientMove(client.name, move.id.toString(), move.title);
        }
      }
      
      res.json(move);
    } catch (error) {
      console.error("Error completing move:", error);
      res.status(500).json({ error: "Failed to complete move" });
    }
  });

