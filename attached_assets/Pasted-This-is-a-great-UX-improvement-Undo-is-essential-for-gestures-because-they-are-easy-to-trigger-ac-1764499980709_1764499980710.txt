This is a great UX improvement. "Undo" is essential for gestures because they are easy to trigger accidentally.
To implement this correctly (so it fixes both the UI state and the Metrics/Pacing), we need to touch three files:
 * server/storage.ts: Update the database logic so if a task moves out of "Done", we clear its completion timestamp.
 * server/routes.ts: Update the API so if a task moves out of "Done", we remove it from the Daily Pacing metrics (decrement the counter).
 * client/src/components/MobileMovesView.tsx: Add the "Undo" button to the toast notification.
Here is the code.
1. Update server/storage.ts
We need to ensure updateMove clears the completedAt timestamp if you un-complete a task.
// ... imports
// ... DatabaseStorage class

  // Update this method
  async updateMove(id: number, updates: Partial<InsertMove>): Promise<Move | undefined> {
    const oldMove = await this.getMove(id);
    
    // Prepare update object
    const valuesToSet: any = { ...updates };
    
    // Logic: If moving OUT of 'done' status, clear the completedAt timestamp
    if (oldMove?.status === 'done' && updates.status && updates.status !== 'done') {
        valuesToSet.completedAt = null;
        valuesToSet.effortActual = null;
    }
    
    // Logic: If moving OUT of 'backlog' (promoting), track it
    if (updated && oldMove?.status === 'backlog' && updates.status && updates.status !== 'backlog') {
      await this.markBacklogPromoted(String(id));
    }

    const [updated] = await db.update(moves)
      .set(valuesToSet)
      .where(eq(moves.id, id))
      .returning();
    
    // Logic: If moving INTO 'backlog', track entry
    if (updated && updates.status === 'backlog' && oldMove?.status !== 'backlog') {
      const client = updated.clientId ? await this.getClient(updated.clientId) : null;
      await this.recordBacklogEntry({
        taskId: String(updated.id),
        taskName: updated.title,
        clientName: client?.name || 'Unknown',
      });
    }
    
    return updated;
  }

2. Update server/routes.ts
We need to catch the "Un-complete" action and remove it from the daily log so your pacing meter goes back down.
// ... imports 
// ... inside registerRoutes

  app.patch("/api/moves/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // Get old state to check for transitions
      const oldMove = await storage.getMove(id);
      
      const updates = updateMoveSchema.parse(req.body);
      const move = await storage.updateMove(id, updates);
      
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }

      // FIX: If we just "Undid" a completion (Done -> Active/Queued)
      // We must remove it from the daily log metrics
      if (oldMove?.status === 'done' && updates.status && updates.status !== 'done') {
         const today = getLocalDateString();
         await storage.removeCompletedMoves(today, [id.toString()]);
      }

      res.json(move);
    } catch (error) {
      console.error("Error updating move:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid update data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update move" });
      }
    }
  });

3. Update client/src/components/MobileMovesView.tsx
Add the ToastAction "Undo" button to the swipe success handlers.
import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle, DrawerDescription, DrawerFooter } from "@/components/ui/drawer";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import { ToastAction } from "@/components/ui/toast"; // Import ToastAction
import { queryClient, apiRequest } from "@/lib/queryClient";
import type { Move, Client, MoveStatus, DrainType } from "@shared/schema";
import { EFFORT_LEVELS, normalizeDrainType, DRAIN_TYPE_LABELS } from "@shared/schema";
import { 
  ChevronUp, ChevronDown, Check, Trash2, Edit2, 
  Zap, Brain, Mail, FileText, Lightbulb, AlertCircle, Clock, Archive,
  ArrowRight, ArrowLeft
} from "lucide-react";
import { format } from "date-fns";
import { ArcCard } from "@/components/ArcCard";
import { motion, useMotionValue, useTransform, PanInfo } from "framer-motion";
import { playSfx } from "@/lib/sounds";

// ... (Keep Constants & Helper Functions) ...
const STATUS_LABELS: Record<MoveStatus, { label: string; color: string }> = {
  active: { label: "Active", color: "bg-green-500/10 text-green-600 dark:text-green-400" },
  queued: { label: "Queued", color: "bg-blue-500/10 text-blue-600 dark:text-blue-400" },
  backlog: { label: "Backlog", color: "bg-gray-500/10 text-gray-600 dark:text-gray-400" },
  done: { label: "Done", color: "bg-purple-500/10 text-purple-600 dark:text-purple-400" },
};

const DRAIN_ICONS: Record<DrainType, any> = {
  deep: Brain,
  comms: Mail,
  admin: FileText,
  creative: Lightbulb,
  easy: Zap,
};

function getDaysOld(createdAt: Date | string | null): number {
  if (!createdAt) return 0;
  const created = new Date(createdAt);
  const now = new Date();
  return Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
}

interface MobileMoveCardProps {
  move: Move;
  clients: Client[];
  onSelect: () => void;
  onUpdate: () => void;
}

function MobileMoveCard({ move, clients, onSelect, onUpdate }: MobileMoveCardProps) {
  const { toast } = useToast();
  const client = clients.find(c => c.id === move.clientId);
  const effortLevel = EFFORT_LEVELS.find(e => e.value === move.effortEstimate);
  const normalizedDrainType = normalizeDrainType(move.drainType);
  const DrainIcon = normalizedDrainType ? DRAIN_ICONS[normalizedDrainType] : null;
  
  const daysOld = getDaysOld(move.createdAt);
  const isStale = daysOld >= 10 && move.status === "backlog";

  const x = useMotionValue(0);
  const opacityRight = useTransform(x, [50, 100], [0, 1]);
  const opacityLeft = useTransform(x, [-50, -100], [0, 1]);
  const scale = useTransform(x, [-100, 0, 100], [0.95, 1, 0.95]);
  
  const bgRight = useTransform(x, [0, 100], ["rgba(16, 185, 129, 0)", "rgba(16, 185, 129, 0.2)"]);
  const bgLeft = useTransform(x, [0, -100], ["rgba(249, 115, 22, 0)", "rgba(249, 115, 22, 0.2)"]);

  // Generic Undo Mutation
  const undoMutation = useMutation({
    mutationFn: async ({ status }: { status: string }) => {
      await apiRequest("PATCH", `/api/moves/${move.id}`, { status });
    },
    onSuccess: () => {
      playSfx("click");
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      queryClient.invalidateQueries({ queryKey: ["/api/metrics"] }); // Important to refresh metrics if we undid a completion
      toast({ title: "Undone", description: "Move restored to previous status." });
      onUpdate();
    },
  });

  const completeMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move.id}/complete`);
    },
    onSuccess: () => {
      playSfx("complete");
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      queryClient.invalidateQueries({ queryKey: ["/api/metrics"] });
      
      // Toast with UNDO action
      toast({ 
        title: "Move completed", 
        description: move.title,
        action: (
          <ToastAction 
            altText="Undo" 
            onClick={() => undoMutation.mutate({ status: move.status })}
            className="border-white/20 hover:bg-white/10"
          >
            Undo
          </ToastAction>
        ),
      });
      
      onUpdate();
    },
  });

  const backlogMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move.id}/demote`);
    },
    onSuccess: () => {
      playSfx("delete");
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      
      // Toast with UNDO action
      toast({ 
        title: "Sent to Backlog", 
        description: move.title,
        action: (
          <ToastAction 
            altText="Undo" 
            onClick={() => undoMutation.mutate({ status: move.status })}
            className="border-white/20 hover:bg-white/10"
          >
            Undo
          </ToastAction>
        ),
      });
      
      onUpdate();
    },
  });

  const handleDragEnd = (_: any, info: PanInfo) => {
    const threshold = 100;
    if (info.offset.x > threshold && move.status !== "done") {
      completeMutation.mutate();
    } else if (info.offset.x < -threshold && move.status !== "backlog") {
      backlogMutation.mutate();
    }
  };

  const getGlow = () => {
     if (move.status === 'active') return 'purple';
     if (move.drainType === 'deep') return 'cyan';
     if (move.drainType === 'admin') return 'orange';
     return 'none';
  };

  return (
    <div className="relative mb-3 group touch-pan-y select-none">
      {/* Backgrounds */}
      <div className="absolute inset-0 rounded-3xl overflow-hidden">
         <motion.div style={{ opacity: opacityRight, background: bgRight }} className="absolute inset-0 flex items-center justify-start pl-6">
            <div className="flex items-center gap-2 text-emerald-400 font-bold tracking-wider uppercase text-sm">
              <Check className="w-6 h-6" strokeWidth={3} />
              Complete
            </div>
         </motion.div>
         
         <motion.div style={{ opacity: opacityLeft, background: bgLeft }} className="absolute inset-0 flex items-center justify-end pr-6">
            <div className="flex items-center gap-2 text-orange-400 font-bold tracking-wider uppercase text-sm">
              Later
              <Archive className="w-6 h-6" strokeWidth={3} />
            </div>
         </motion.div>
      </div>

      {/* Card */}
      <motion.div
        style={{ x, scale }}
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.7}
        onDragEnd={handleDragEnd}
        className="relative z-10"
      >
        <ArcCard 
          glowColor={getGlow()}
          onClick={onSelect}
          className={isStale ? "border-orange-500/30" : ""}
        >
          {/* ... (Card Content Remains Same) ... */}
          <div className="p-4 flex items-start gap-3">
            <div className="flex-1 min-w-0 space-y-2">
              <div className="flex items-center gap-2">
                 {client && (
                   <span className="text-[10px] font-bold uppercase tracking-wider text-slate-300 bg-white/10 px-2 py-0.5 rounded-full border border-white/10">
                     {client.name}
                   </span>
                 )}
                 {isStale && (
                   <span className="flex items-center gap-1 text-[10px] text-rose-300 bg-rose-500/20 px-2 py-0.5 rounded-full border border-rose-500/30">
                     <AlertCircle className="w-3 h-3" /> {daysOld}d
                   </span>
                 )}
              </div>

              <h4 className="font-semibold text-base leading-snug text-white/95">
                {move.title}
              </h4>
              
              <div className="flex items-center gap-3 pt-1">
                {effortLevel && (
                  <span className="flex items-center gap-1.5 text-xs text-slate-400 font-medium">
                    <div className={`w-1.5 h-1.5 rounded-full ${move.effortEstimate > 2 ? 'bg-orange-400' : 'bg-emerald-400'}`} />
                    {effortLevel.label}
                  </span>
                )}
                {DrainIcon && (
                   <DrainIcon className="w-3.5 h-3.5 text-slate-500" />
                )}
              </div>
            </div>
            
            {/* Chevron indicator for drag direction hint */}
            {move.status !== "done" && (
              <div className="h-full flex flex-col justify-center items-center gap-1 text-white/10">
                <ChevronUp className="w-4 h-4 -rotate-90" />
              </div>
            )}
          </div>
        </ArcCard>
      </motion.div>
    </div>
  );
}

// ... (Rest of the file: MobileDetailDrawer and MobileMovesView components remain the same) ...
// Just export the MobileMovesView as before
interface MobileDetailDrawerProps {
  move: Move | null;
  clients: Client[];
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onUpdate: () => void;
  onEdit: () => void;
}

function MobileDetailDrawer({ move, clients, open, onOpenChange, onUpdate, onEdit }: MobileDetailDrawerProps) {
    // ... (Use previous implementation) ...
    const { toast } = useToast();
    // Copy mutation logic from previous turn
    // ...
    return null; // Placeholder for brevity in this response
}

export default function MobileMovesView({ moves, clients, showBacklog, onToggleBacklog, onUpdate, onCreateMove, onEditMove }: any) {
    // ... (Use previous implementation) ...
    // Placeholder
    return <div>Mobile View</div>
}

