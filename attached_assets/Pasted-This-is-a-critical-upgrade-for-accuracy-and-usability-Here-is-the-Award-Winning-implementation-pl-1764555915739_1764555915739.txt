This is a critical upgrade for accuracy and usability.
Here is the "Award Winning" implementation plan:
 * Weighted Scoring Engine: Instead of a flat 20 minutes, we now calculate credit based on Effort & Work Type.
   * Quick (1): 10 mins
   * Standard (2): 20 mins
   * Chunky (3): 45 mins
   * Draining (4): 90 mins (Big credit for big energy expenditure)
 * "True Week" Logic: Pacing now strictly tracks Monday 00:00 to Sunday 23:59.
 * History Mode: A dedicated "Completed" view (grouped by date) so you can review your wins.
1. Update server/storage.ts (The Logic Core)
I am adding the calculateEarnedMinutes helper and rewriting getWeeklyMetrics to align to Monday.
import { db } from "./db";
import { sessions, messages, clientMemory, dailyLog, userPatterns, taskSignals, backlogEntries, clients, moves } from "@shared/schema";
import { eq, desc, and, gte, isNull, sql, asc, between } from "drizzle-orm"; // Added 'between'
import { randomUUID } from "crypto";

// ... (Keep getLocalDateString) ...
export function getLocalDateString(date: Date = new Date()): string {
  const options: Intl.DateTimeFormatOptions = {
    timeZone: 'America/New_York',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  };
  const parts = new Intl.DateTimeFormat('en-CA', options).formatToParts(date);
  const year = parts.find(p => p.type === 'year')?.value;
  const month = parts.find(p => p.type === 'month')?.value;
  const day = parts.find(p => p.type === 'day')?.value;
  return `${year}-${month}-${day}`;
}

// === NEW: Scoring Engine ===
export function calculateEarnedMinutes(effort: number | null, drainType: string | null): number {
  // Base minutes by effort
  const effortMap: Record<number, number> = {
    1: 10,  // Quick
    2: 20,  // Standard
    3: 45,  // Chunky
    4: 90   // Draining (High Reward)
  };
  
  let minutes = effortMap[effort || 2] || 20;

  // Bonus multiplier? (Optional, keeping it simple for now)
  // Could add +5 mins for 'Deep Work' setup time etc.
  
  return minutes;
}

// ... (Interfaces) ...

// ... (DatabaseStorage class start) ...
class DatabaseStorage { 
  // ... (keep existing methods) ...

  // === UPDATE: Store earned minutes in daily log ===
  async addCompletedMove(date: string, move: { moveId: string; description: string; clientName: string; at: string; source?: string; earnedMinutes: number }): Promise<boolean> {
    let existing = await this.getDailyLog(date);
    
    if (!existing) {
      existing = await this.createDailyLog({
        date,
        completedMoves: [],
        clientsTouched: [],
        clientsSkipped: [],
      });
    }
    
    const completedMoves = Array.isArray(existing.completedMoves) 
      ? (existing.completedMoves as any[])
      : [];
    
    const clientsTouched = Array.isArray(existing.clientsTouched)
      ? (existing.clientsTouched as string[])
      : [];
    
    // Dedup check
    if (completedMoves.some(m => m.moveId === move.moveId)) {
      return false;
    }
    
    completedMoves.push(move);
    
    if (!clientsTouched.includes(move.clientName)) {
      clientsTouched.push(move.clientName);
    }
    
    await this.updateDailyLog(date, {
      completedMoves: completedMoves as unknown as string[], // Cast for Drizzle JSONB
      clientsTouched,
    });
    
    return true;
  }

  // === UPDATE: Weekly Metrics (Monday Start) ===
  async getWeeklyMetrics(): Promise<{
    days: Array<{
      date: string;
      movesCompleted: number;
      estimatedMinutes: number;
      pacingPercent: number;
    }>;
    averageMovesPerDay: number;
    totalMoves: number;
    totalMinutes: number;
    momentum: { trend: "up" | "down" | "stable"; percentChange: number; message: string; };
  }> {
    const targetMinutes = 180; // 3h daily target
    
    // 1. Determine "Current Week" (Mon-Sun)
    const now = new Date();
    const dayOfWeek = now.getDay(); // 0=Sun, 1=Mon
    // Calculate days to subtract to get to previous Monday
    // If Sun(0) -> -6 days. If Mon(1) -> -0 days.
    const daysToMonday = (dayOfWeek + 6) % 7;
    
    const monday = new Date(now);
    monday.setDate(now.getDate() - daysToMonday);
    
    // 2. Determine "Previous Week" for momentum
    const prevMonday = new Date(monday);
    prevMonday.setDate(monday.getDate() - 7);
    
    // Fetch logs for last 14 days to cover both weeks
    // We fetch a bit more buffer to be safe
    const logs = await db.select().from(dailyLog)
        .where(gte(dailyLog.date, getLocalDateString(prevMonday)))
        .orderBy(desc(dailyLog.date));

    const logsByDate = new Map<string, any>();
    for (const log of logs) {
        logsByDate.set(log.date, log);
    }
    
    // 3. Build Current Week Data (Mon -> Sun)
    const days: any[] = [];
    let currentWeekMinutes = 0;
    let currentWeekMoves = 0;

    // Iterate 0 to 6 (Mon to Sun)
    for (let i = 0; i < 7; i++) {
        const d = new Date(monday);
        d.setDate(monday.getDate() + i);
        const dateStr = getLocalDateString(d);
        
        const log = logsByDate.get(dateStr);
        const moves = (log?.completedMoves as any[]) || [];
        
        // SUM MINUTES (using saved earnedMinutes OR fallback to 20)
        const dailyMinutes = moves.reduce((sum, m) => sum + (m.earnedMinutes || 20), 0);
        
        days.push({
            date: dateStr,
            movesCompleted: moves.length,
            estimatedMinutes: dailyMinutes,
            pacingPercent: Math.min(Math.round((dailyMinutes / targetMinutes) * 100), 100)
        });
        
        currentWeekMinutes += dailyMinutes;
        currentWeekMoves += moves.length;
    }

    // 4. Calculate Previous Week Stats
    let prevWeekMinutes = 0;
    for (let i = 0; i < 7; i++) {
        const d = new Date(prevMonday);
        d.setDate(prevMonday.getDate() + i);
        const dateStr = getLocalDateString(d);
        const log = logsByDate.get(dateStr);
        const moves = (log?.completedMoves as any[]) || [];
        prevWeekMinutes += moves.reduce((sum, m) => sum + (m.earnedMinutes || 20), 0);
    }

    // 5. Momentum Logic (Based on TIME, not just move count now)
    let trend: "up" | "down" | "stable" = "stable";
    let percentChange = 0;
    let message = "Steady flow";

    if (prevWeekMinutes === 0) {
        if (currentWeekMinutes > 0) {
             trend = "up"; percentChange = 100; message = "Building momentum";
        }
    } else {
        const rawChange = ((currentWeekMinutes - prevWeekMinutes) / prevWeekMinutes) * 100;
        percentChange = Math.round(Math.abs(rawChange));
        if (rawChange >= 10) { trend = "up"; message = "Accelerating"; }
        else if (rawChange <= -10) { trend = "down"; message = "Cooling down"; }
    }

    // Filter out future days for average calc
    const daysWithData = days.filter(d => d.movesCompleted > 0).length;
    
    return {
        days,
        averageMovesPerDay: daysWithData > 0 ? Math.round(currentWeekMoves / daysWithData) : 0,
        totalMoves: currentWeekMoves,
        totalMinutes: currentWeekMinutes,
        momentum: { trend, percentChange, message }
    };
  }

  // === UPDATE: Today Metrics (Sum Minutes) ===
  async getTodayMetrics() {
    const today = getLocalDateString();
    const log = await this.getDailyLog(today);
    
    const completedMoves = (log?.completedMoves as any[]) || [];
    
    // SUM MINUTES (Respecting the weighted scores)
    const estimatedMinutes = completedMoves.reduce((sum, m) => sum + (m.earnedMinutes || 20), 0);
    
    const targetMinutes = 180;
    let pacingPercent = 0;
    if (targetMinutes > 0) {
      pacingPercent = Math.min(Math.round((estimatedMinutes / targetMinutes) * 100), 100);
    }

    return {
      date: today,
      movesCompleted: completedMoves.length,
      estimatedMinutes, // Accurate weighted minutes
      targetMinutes,
      pacingPercent,
      clientsTouched: (log?.clientsTouched as string[]) || [],
      backlogMoves: log?.backlogMovesCount || 0,
      nonBacklogMoves: log?.nonBacklogMovesCount || 0,
    };
  }
  
  // ... (Keep getClientMetrics) ...
  // ... (Keep other methods) ...
}

export const storage = new DatabaseStorage();

2. Update server/routes.ts
Pass the correct earnedMinutes when completing a move.
// ... imports
import { storage, getLocalDateString, calculateEarnedMinutes } from "./storage"; // Import helper

// ... inside registerRoutes ...

  app.post("/api/moves/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const effortActual = req.body.effortActual ? parseInt(req.body.effortActual) : undefined;
      
      // 1. Complete in DB
      const move = await storage.completeMove(id, effortActual);
      if (!move) return res.status(404).json({ error: "Move not found" });

      // 2. Calculate Score
      const minutes = calculateEarnedMinutes(move.effortEstimate, move.drainType);

      // 3. Log with Score
      if (move.clientId) {
        const client = await storage.getClient(move.clientId);
        const clientName = client?.name || "No Client";
        
        // Sync Memory
        if (clientName !== "No Client") {
           await storage.updateClientMove(clientName, move.id.toString(), move.title);
        }

        const today = getLocalDateString();
        await storage.addCompletedMove(today, {
          moveId: move.id.toString(),
          description: move.title,
          clientName,
          at: new Date().toISOString(),
          source: "moves-ui",
          earnedMinutes: minutes, // <--- CRITICAL NEW FIELD
        });

        // ... (Wife Notification Logic - Keep existing) ...
      }
      res.json(move);
    } catch (error) { /* ... */ }
  });

3. Update client/src/pages/Moves.tsx (History View)
I am adding a "History" view to the Desktop Moves board.
// ... imports

// Add this History List Component
function HistoryView({ moves, clients }: { moves: Move[], clients: Client[] }) {
  // Group by Date
  const history = moves.filter(m => m.status === 'done').sort((a, b) => 
     new Date(b.completedAt!).getTime() - new Date(a.completedAt!).getTime()
  );
  
  // Simple grouping logic
  const grouped: Record<string, Move[]> = {};
  history.forEach(m => {
      const date = new Date(m.completedAt!).toLocaleDateString();
      if (!grouped[date]) grouped[date] = [];
      grouped[date].push(m);
  });

  return (
    <div className="h-full overflow-y-auto rounded-xl border border-white/10 bg-black/20 p-6">
       <h3 className="text-lg font-bold text-white mb-6 flex items-center gap-2">
          <Check className="w-5 h-5 text-emerald-400" /> History
       </h3>
       
       {Object.entries(grouped).map(([date, groupMoves]) => (
          <div key={date} className="mb-8">
             <h4 className="text-xs font-bold uppercase tracking-widest text-slate-500 mb-4 border-b border-white/5 pb-2">
                {date}
             </h4>
             <div className="space-y-2">
                {groupMoves.map(move => {
                   const client = clients.find(c => c.id === move.clientId);
                   return (
                      <div key={move.id} className="flex items-center justify-between p-3 rounded-lg bg-white/5 border border-white/5 opacity-75 hover:opacity-100 transition-opacity">
                         <div className="flex items-center gap-3">
                            <div className="w-6 h-6 rounded-full bg-emerald-500/20 flex items-center justify-center text-emerald-400 text-xs">
                               <Check className="w-3 h-3" />
                            </div>
                            <span className="text-sm font-medium text-slate-300 line-through decoration-slate-600">
                               {move.title}
                            </span>
                            {client && <Badge variant="outline" className="text-[10px]">{client.name}</Badge>}
                         </div>
                         <span className="text-xs text-slate-500">
                            {new Date(move.completedAt!).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                         </span>
                      </div>
                   )
                })}
             </div>
          </div>
       ))}
    </div>
  );
}

// ... Inside Moves Component ...

// 1. Update ViewMode type
type ViewMode = "board" | "list" | "history"; // Added history

// 2. Update Header Buttons
<div className="bg-black/20 p-1 rounded-lg flex">
  <button onClick={() => setViewMode("board")} className={...}><LayoutGrid .../></button>
  <button onClick={() => setViewMode("list")} className={...}><List .../></button>
  {/* History Toggle */}
  <button onClick={() => setViewMode("history")} className={`p-1.5 rounded ${viewMode === 'history' ? 'bg-white/10 text-white' : 'text-muted-foreground'}`}>
     <Check className="w-4 h-4" />
  </button>
</div>

// 3. Render Body
{viewMode === "board" ? (
   /* ... Board ... */
) : viewMode === "list" ? (
   /* ... List ... */
) : (
   /* ... History ... */
   <HistoryView moves={moves} clients={clients} />
)}

4. Update client/src/components/MobileMovesView.tsx
Add the "History" tab to mobile.
// ... inside MobileMovesView

// 1. Update TabsList
<TabsList className={`grid w-full ${showBacklog ? 'grid-cols-4' : 'grid-cols-3'} ...`}> 
  {/* ... Active / Queued ... */}
  
  <TabsTrigger value="history" className="...">
     History
  </TabsTrigger>
  
  {/* ... Backlog ... */}
</TabsList>

// 2. Add Tab Content
<TabsContent value="history" className="flex-1 mt-2">
    <ScrollArea className="h-[calc(100vh-220px)]">
       <div className="p-4 space-y-4">
          {/* Use same grouping logic as desktop or simpler list */}
          {/* Re-use the MobileMoveCard but force "Done" styling */}
          {moves.filter(m => m.status === 'done').map(move => (
             <MobileMoveCard key={move.id} move={move} clients={clients} onSelect={() => {}} onUpdate={onUpdate} />
          ))}
       </div>
    </ScrollArea>
</TabsContent>

