This is a logic bug in the backend.
The issue is in server/routes.ts. Currently, the system only logs a completed task to your Daily Metrics if that task is assigned to a specific Client ID. If you created a quick task without assigning a client (or if it was an "Internal" task), the system marks it as done but skips the daily log, causing your "Today" and "Weekly" numbers to stay at zero.
Here is the fix.
1. Fix server/routes.ts
I am removing the condition that requires a clientId to log the metric. Now, every completed move will count toward your 3-hour target, labeled as "No Client" if necessary.
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage, getLocalDateString } from "./storage";
import { processChat } from "./openai-service";
import { runTriage, runTriageWithAutoRemediation } from "./pipeline-tools";
import { z } from "zod";
import { insertClientSchema, insertMoveSchema, MOVE_STATUSES, type MoveStatus } from "@shared/schema";

const sendMessageSchema = z.object({
  sessionId: z.string().optional().nullable(),
  message: z.string().min(1),
  imageUrl: z.string().optional().nullable(),
  imageBase64: z.string().optional().nullable(),
  imagesBase64: z.array(z.string()).optional().nullable(),
});

const updateMoveSchema = z.object({
  title: z.string().optional(),
  description: z.string().nullable().optional(),
  status: z.enum(MOVE_STATUSES).optional(),
  clientId: z.number().nullable().optional(),
  effortEstimate: z.number().optional(),
  effortActual: z.number().nullable().optional(),
  drainType: z.string().nullable().optional(),
  sortOrder: z.number().optional(),
});

const updateClientSchema = z.object({
  name: z.string().optional(),
  type: z.string().optional(),
  color: z.string().nullable().optional(),
  isActive: z.number().optional(),
});

export async function registerRoutes(app: Express): Promise<Server> {

  app.post("/api/sessions", async (req, res) => {
    try {
      const session = await storage.createSession({});
      res.json(session);
    } catch (error) {
      console.error("Error creating session:", error);
      res.status(500).json({ error: "Failed to create session" });
    }
  });

  app.get("/api/sessions/:id/messages", async (req, res) => {
    try {
      const messages = await storage.getMessages(req.params.id);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ error: "Failed to fetch messages" });
    }
  });

  app.post("/api/chat", async (req, res) => {
    try {
      const { sessionId: providedSessionId, message, imageUrl, imageBase64, imagesBase64 } = sendMessageSchema.parse(req.body);

      let sessionId = providedSessionId;
      if (!sessionId) {
        const session = await storage.createSession({});
        sessionId = session.id;
      }

      const allImages = imagesBase64 || (imageBase64 ? [imageBase64] : undefined);
      const hasImages = allImages && allImages.length > 0;

      const userMessage = await storage.createMessage({
        sessionId,
        role: "user",
        content: hasImages ? `[${allImages.length > 1 ? 'Images' : 'Image'} attached]\n${message}` : message,
      });

      const conversationHistory = await storage.getSessionMessages(sessionId, 20);

      const { content, taskCard } = await processChat(
        conversationHistory, 
        imageUrl || undefined, 
        allImages
      );

      const assistantMessage = await storage.createMessage({
        sessionId,
        role: "assistant",
        content,
        taskCard,
      });

      await storage.updateSessionActivity(sessionId);

      res.json({
        sessionId,
        userMessage,
        assistantMessage,
      });
    } catch (error) {
      console.error("Error processing chat:", error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : "Failed to process chat" 
      });
    }
  });

  app.get("/api/health", async (req, res) => {
    res.json({
      status: "ok",
    });
  });

  // Metrics endpoints
  app.get("/api/metrics/today", async (req, res) => {
    try {
      const metrics = await storage.getTodayMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching today's metrics:", error);
      res.status(500).json({ error: "Failed to fetch metrics" });
    }
  });

  app.get("/api/metrics/weekly", async (req, res) => {
    try {
      const metrics = await storage.getWeeklyMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching weekly metrics:", error);
      res.status(500).json({ error: "Failed to fetch weekly metrics" });
    }
  });

  app.get("/api/metrics/clients", async (req, res) => {
    try {
      const metrics = await storage.getClientMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching client metrics:", error);
      res.status(500).json({ error: "Failed to fetch client metrics" });
    }
  });

  app.get("/api/metrics/drain-types", async (req, res) => {
    try {
      const daysBack = req.query.days ? parseInt(req.query.days as string) : 30;
      const metrics = await storage.getDrainTypeMetrics(daysBack);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching drain type metrics:", error);
      res.status(500).json({ error: "Failed to fetch drain type metrics" });
    }
  });

  app.get("/api/metrics/productivity", async (req, res) => {
    try {
      const metrics = await storage.getProductivityByHour();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching productivity metrics:", error);
      res.status(500).json({ error: "Failed to fetch productivity metrics" });
    }
  });

  app.get("/api/metrics/backlog-health", async (req, res) => {
    try {
      const health = await storage.getBacklogHealth();
      res.json(health);
    } catch (error) {
      console.error("Error fetching backlog health:", error);
      res.status(500).json({ error: "Failed to fetch backlog health" });
    }
  });

  app.get("/api/metrics/avoided-tasks", async (req, res) => {
    try {
      const daysBack = req.query.days ? parseInt(req.query.days as string) : 14;
      const tasks = await storage.getAvoidedTasks(daysBack);
      res.json(tasks);
    } catch (error) {
      console.error("Error fetching avoided tasks:", error);
      res.status(500).json({ error: "Failed to fetch avoided tasks" });
    }
  });

  app.get("/api/metrics/patterns", async (req, res) => {
    try {
      const patternType = req.query.type as string | undefined;
      const patterns = await storage.getPatterns(patternType);
      res.json(patterns);
    } catch (error) {
      console.error("Error fetching patterns:", error);
      res.status(500).json({ error: "Failed to fetch patterns" });
    }
  });

  const sentimentSchema = z.object({
    sentiment: z.enum(["positive", "neutral", "negative", "complicated"]),
  });

  app.patch("/api/client-memory/:clientName/sentiment", async (req, res) => {
    try {
      const clientName = decodeURIComponent(req.params.clientName).toLowerCase().trim();
      const parseResult = sentimentSchema.safeParse(req.body);
      if (!parseResult.success) {
        res.status(400).json({ error: "Invalid sentiment value", details: parseResult.error.errors });
        return;
      }
      const { sentiment } = parseResult.data;
      const updated = await storage.updateClientSentiment(clientName, sentiment);
      if (!updated) {
        res.status(404).json({ error: "Client not found" });
        return;
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating client sentiment:", error);
      res.status(500).json({ error: "Failed to update client sentiment" });
    }
  });

  const importanceSchema = z.object({
    importance: z.enum(["high", "medium", "low"]),
  });

  app.patch("/api/client-memory/:clientName/importance", async (req, res) => {
    try {
      const clientName = decodeURIComponent(req.params.clientName).toLowerCase().trim();
      const parseResult = importanceSchema.safeParse(req.body);
      if (!parseResult.success) {
        res.status(400).json({ error: "Invalid importance value", details: parseResult.error.errors });
        return;
      }
      const { importance } = parseResult.data;
      const updated = await storage.updateClientImportance(clientName, importance);
      if (!updated) {
        res.status(404).json({ error: "Client not found" });
        return;
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating client importance:", error);
      res.status(500).json({ error: "Failed to update client importance" });
    }
  });

  // ============ CLIENTS API ============

  app.get("/api/clients", async (req, res) => {
    try {
      const clients = await storage.getAllClientsEntity();
      res.json(clients);
    } catch (error) {
      console.error("Error fetching clients:", error);
      res.status(500).json({ error: "Failed to fetch clients" });
    }
  });

  app.post("/api/clients", async (req, res) => {
    try {
      const data = insertClientSchema.parse(req.body);
      const client = await storage.createClient(data);
      res.status(201).json(client);
    } catch (error) {
      console.error("Error creating client:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid client data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create client" });
      }
    }
  });

  app.get("/api/clients/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const client = await storage.getClient(id);
      if (!client) {
        res.status(404).json({ error: "Client not found" });
        return;
      }
      res.json(client);
    } catch (error) {
      console.error("Error fetching client:", error);
      res.status(500).json({ error: "Failed to fetch client" });
    }
  });

  app.patch("/api/clients/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = updateClientSchema.parse(req.body);
      const client = await storage.updateClient(id, updates);
      if (!client) {
        res.status(404).json({ error: "Client not found" });
        return;
      }
      res.json(client);
    } catch (error) {
      console.error("Error updating client:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid update data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update client" });
      }
    }
  });

  app.delete("/api/clients/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.archiveClient(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error archiving client:", error);
      res.status(500).json({ error: "Failed to archive client" });
    }
  });

  // ============ MOVES API ============

  app.get("/api/moves", async (req, res) => {
    try {
      const status = req.query.status as MoveStatus | undefined;
      const clientId = req.query.clientId ? parseInt(req.query.clientId as string) : undefined;
      const includeCompleted = req.query.includeCompleted === "true";
      
      const moves = await storage.getAllMoves({ status, clientId, includeCompleted });
      res.json(moves);
    } catch (error) {
      console.error("Error fetching moves:", error);
      res.status(500).json({ error: "Failed to fetch moves" });
    }
  });

  app.post("/api/moves", async (req, res) => {
    try {
      const data = insertMoveSchema.parse(req.body);
      const move = await storage.createMove(data);
      res.status(201).json(move);
    } catch (error) {
      console.error("Error creating move:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid move data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create move" });
      }
    }
  });

  app.get("/api/moves/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const move = await storage.getMove(id);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      res.json(move);
    } catch (error) {
      console.error("Error fetching move:", error);
      res.status(500).json({ error: "Failed to fetch move" });
    }
  });

  app.patch("/api/moves/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = updateMoveSchema.parse(req.body);
      const move = await storage.updateMove(id, updates);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      res.json(move);
    } catch (error) {
      console.error("Error updating move:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid update data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update move" });
      }
    }
  });

  app.post("/api/moves/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const effortActual = req.body.effortActual ? parseInt(req.body.effortActual) : undefined;
      const move = await storage.completeMove(id, effortActual);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      
      // FIX: Log to daily metrics for ALL completed moves, even if client is null
      let clientName = "No Client";
      if (move.clientId) {
        const client = await storage.getClient(move.clientId);
        if (client) {
          clientName = client.name;
        }
      }
      
      const today = getLocalDateString();
      await storage.addCompletedMove(today, {
        moveId: move.id.toString(),
        description: move.title,
        clientName: clientName,
        at: new Date().toISOString(),
        source: "moves-ui",
      });
      
      res.json(move);
    } catch (error) {
      console.error("Error completing move:", error);
      res.status(500).json({ error: "Failed to complete move" });
    }
  });

  app.post("/api/moves/:id/promote", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const move = await storage.promoteMove(id);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      res.json(move);
    } catch (error) {
      console.error("Error promoting move:", error);
      res.status(500).json({ error: "Failed to promote move" });
    }
  });

  app.post("/api/moves/:id/demote", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const move = await storage.demoteMove(id);
      if (!move) {
        res.status(404).json({ error: "Move not found" });
        return;
      }
      res.json(move);
    } catch (error) {
      console.error("Error demoting move:", error);
      res.status(500).json({ error: "Failed to demote move" });
    }
  });

  app.delete("/api/moves/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteMove(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting move:", error);
      res.status(500).json({ error: "Failed to delete move" });
    }
  });

  app.post("/api/moves/reorder", async (req, res) => {
    try {
      const { status, orderedIds } = req.body;
      if (!status || !Array.isArray(orderedIds)) {
        res.status(400).json({ error: "status and orderedIds are required" });
        return;
      }
      await storage.reorderMoves(status as MoveStatus, orderedIds);
      res.json({ success: true });
    } catch (error) {
      console.error("Error reordering moves:", error);
      res.status(500).json({ error: "Failed to reorder moves" });
    }
  });

  app.get("/api/triage", async (req, res) => {
    try {
      const result = await runTriage();
      res.json(result);
    } catch (error) {
      console.error("Error running triage:", error);
      res.status(500).json({ error: "Failed to run triage" });
    }
  });

  app.post("/api/triage/auto-fix", async (req, res) => {
    try {
      const result = await runTriageWithAutoRemediation();
      res.json(result);
    } catch (error) {
      console.error("Error running triage with auto-fix:", error);
      res.status(500).json({ error: "Failed to run triage with auto-fix" });
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}

2. Update client/src/pages/Metrics.tsx
I have boosted the readability of the Weekly Trends list text (changed from "muted" to clearer white/cyan colors) so you can clearly see the days and hour counts.
import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { 
  Clock, Target, TrendingUp, Users, AlertCircle, CheckCircle2, 
  Brain, MessageCircle, FileText, Lightbulb, Zap, Archive, 
  ThumbsUp, ThumbsDown, Minus, AlertTriangle, Star, Loader2 
} from "lucide-react";
import { DRAIN_TYPE_LABELS, type DrainType } from "@shared/schema";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import GlassSidebar from "@/components/GlassSidebar";
import IslandLayout from "@/components/IslandLayout";
import { TriageDialog } from "@/components/TriageDialog";
import { ArcCard } from "@/components/ArcCard";

// ... (Interfaces kept same)
interface TodayMetrics {
  date: string;
  movesCompleted: number;
  estimatedMinutes: number;
  targetMinutes: number;
  pacingPercent: number;
  clientsTouched: string[];
  backlogMoves: number;
  nonBacklogMoves: number;
}

interface WeeklyMetrics {
  days: Array<{
    date: string;
    movesCompleted: number;
    estimatedMinutes: number;
    pacingPercent: number;
  }>;
  averageMovesPerDay: number;
  totalMoves: number;
  totalMinutes: number;
}

interface ClientMetric {
  clientName: string;
  totalMoves: number;
  lastMoveAt: string | null;
  daysSinceLastMove: number;
  sentiment: string;
  importance: string;
  tier: string;
}

interface DrainTypeMetric {
  drainType: string;
  count: number;
  minutes: number;
  percentage: number;
}

interface BacklogHealthMetric {
  clientName: string;
  oldestDays: number;
  agingCount: number;
  totalCount: number;
  avgDays: number;
}

interface ProductivityHour {
  hour: number;
  completions: number;
  deferrals: number;
}

const DRAIN_ICONS: Record<string, typeof Brain> = {
  deep: Brain,
  comms: MessageCircle,
  admin: FileText,
  creative: Lightbulb,
  easy: Zap,
};

const DRAIN_COLORS: Record<string, string> = {
  deep: "bg-cyan-500",
  comms: "bg-green-500",
  admin: "bg-orange-500",
  creative: "bg-purple-500",
  easy: "bg-yellow-500",
  unset: "bg-gray-500",
};

function formatMinutesToHours(minutes: number): string {
  const hours = (minutes / 60).toFixed(1);
  return `${hours}h`;
}

export default function Metrics() {
  const [triageOpen, setTriageOpen] = useState(false);
  const { toast } = useToast();

  const { data: todayMetrics, isLoading: loadingToday } = useQuery<TodayMetrics>({
    queryKey: ["/api/metrics/today"],
  });

  const { data: weeklyMetrics, isLoading: loadingWeekly } = useQuery<WeeklyMetrics>({
    queryKey: ["/api/metrics/weekly"],
  });

  const { data: clientMetrics, isLoading: loadingClients } = useQuery<ClientMetric[]>({
    queryKey: ["/api/metrics/clients"],
  });

  const { data: drainMetrics, isLoading: loadingDrain } = useQuery<DrainTypeMetric[]>({
    queryKey: ["/api/metrics/drain-types"],
  });

  const { data: backlogHealth, isLoading: loadingBacklog } = useQuery<BacklogHealthMetric[]>({
    queryKey: ["/api/metrics/backlog-health"],
  });

  const { data: productivityData, isLoading: loadingProductivity } = useQuery<ProductivityHour[]>({
    queryKey: ["/api/metrics/productivity"],
  });

  const updateSentiment = useMutation({
    mutationFn: async ({ clientName, sentiment }: { clientName: string; sentiment: string }) => {
      return apiRequest("PATCH", `/api/client-memory/${encodeURIComponent(clientName)}/sentiment`, { sentiment });
    },
    onSuccess: (_, { clientName }) => {
      queryClient.invalidateQueries({ queryKey: ["/api/metrics/clients"] });
      toast({ title: "Updated", description: `${clientName} sentiment saved` });
    },
  });

  const updateImportance = useMutation({
    mutationFn: async ({ clientName, importance }: { clientName: string; importance: string }) => {
      return apiRequest("PATCH", `/api/client-memory/${encodeURIComponent(clientName)}/importance`, { importance });
    },
    onSuccess: (_, { clientName }) => {
      queryClient.invalidateQueries({ queryKey: ["/api/metrics/clients"] });
      toast({ title: "Updated", description: `${clientName} priority saved` });
    },
  });

  const weeklyTargetMinutes = 900; // 15 hours
  const weeklyHours = weeklyMetrics ? (weeklyMetrics.totalMinutes / 60).toFixed(1) : "0.0";
  const weeklyPacing = weeklyMetrics ? Math.min(Math.round((weeklyMetrics.totalMinutes / weeklyTargetMinutes) * 100), 100) : 0;

  const MetricsContent = (
    <div className="space-y-6 w-full overflow-x-hidden">
      
      {/* Today's Pacing */}
      <ArcCard glowColor="purple" className="w-full">
        <div className="p-5 sm:p-6">
          <div className="flex flex-row items-center justify-between gap-2 pb-4">
            <div className="text-lg font-semibold flex items-center gap-2 text-white">
              <Target className="h-5 w-5 text-purple-400" />
              Today's Pacing
            </div>
            {todayMetrics && (
              <Badge className="bg-purple-500/20 text-purple-300 border-purple-500/30">
                {todayMetrics.pacingPercent}%
              </Badge>
            )}
          </div>
          
          {loadingToday ? (
            <Skeleton className="h-12 w-full bg-white/5" />
          ) : todayMetrics ? (
            <>
              <div className="flex justify-between text-sm mb-2 text-white/80">
                <span>{formatMinutesToHours(todayMetrics.estimatedMinutes)} of 3.0h target</span>
                <span>{todayMetrics.movesCompleted} moves</span>
              </div>
              <div className="h-3 bg-black/40 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-500" 
                  style={{ width: `${Math.min(todayMetrics.pacingPercent, 100)}%` }} 
                />
              </div>
              <div className="flex gap-4 mt-4 text-xs text-muted-foreground">
                <span>{todayMetrics.backlogMoves} from backlog</span>
                <span>{todayMetrics.clientsTouched.length} clients touched</span>
              </div>
            </>
          ) : <p className="text-muted-foreground">No data</p>}
        </div>
      </ArcCard>

      {/* Weekly Trends (The "Meter List" View) */}
      <ArcCard glowColor="cyan" className="w-full">
        <div className="p-5 sm:p-6">
          <div className="flex items-center justify-between pb-6">
            <div className="text-lg font-semibold flex items-center gap-2 text-white">
              <TrendingUp className="h-5 w-5 text-cyan-400" />
              Weekly Trends
            </div>
            <Badge className="bg-cyan-500/20 text-cyan-300 border-cyan-500/30">
              {weeklyHours}h / 15h
            </Badge>
          </div>

          {loadingWeekly ? (
            <Skeleton className="h-40 w-full bg-white/5" />
          ) : weeklyMetrics ? (
            <div className="space-y-5">
              {/* List of Days with Meters */}
              <div className="space-y-4">
                {weeklyMetrics.days.map((day) => {
                  const dailyHours = (day.estimatedMinutes / 60).toFixed(1);
                  const isZero = day.estimatedMinutes === 0;
                  const dayName = new Date(day.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long' });
                  const percent = Math.min((day.estimatedMinutes / 180) * 100, 100); // Based on 3h daily target

                  return (
                    <div key={day.date} className="flex items-center gap-4">
                      <div className="w-24 shrink-0 text-sm text-slate-300 font-medium">
                        {dayName}
                      </div>
                      
                      <div className="flex-1 h-3 bg-black/40 rounded-full overflow-hidden relative">
                        <div 
                          className={`h-full rounded-full transition-all duration-500 ${isZero ? 'bg-transparent' : 'bg-cyan-500'}`}
                          style={{ width: `${percent}%` }}
                        />
                      </div>

                      <div className={`w-12 shrink-0 text-right text-sm font-bold ${isZero ? 'text-white/30' : 'text-cyan-300'}`}>
                        {dailyHours}h
                      </div>
                    </div>
                  );
                })}
              </div>

              <div className="flex justify-between text-sm text-muted-foreground border-t border-white/5 pt-4 mt-2">
                 <div>
                    <span className="text-white font-bold">{weeklyMetrics.totalMoves}</span> <span className="text-[10px] uppercase tracking-wider">Moves</span>
                 </div>
                 <div>
                    <span className="text-cyan-400 font-bold">{weeklyMetrics.averageMovesPerDay}</span> <span className="text-[10px] uppercase tracking-wider">Avg/Day</span>
                 </div>
              </div>
            </div>
          ) : <p className="text-muted-foreground">No data</p>}
        </div>
      </ArcCard>

      {/* ... (Rest of components kept same) ... */}
      {/* Work Type Breakdown */}
      <ArcCard glowColor="orange" className="w-full">
        <div className="p-5 sm:p-6">
          <div className="text-lg font-semibold flex items-center gap-2 text-white pb-4">
            <Brain className="h-5 w-5 text-orange-400" />
            Work Type Breakdown
          </div>
          
          {loadingDrain ? (
            <Skeleton className="h-24 w-full bg-white/5" />
          ) : drainMetrics && drainMetrics.length > 0 ? (
            <div className="space-y-4">
              <div className="flex h-3 rounded-full overflow-hidden bg-black/40">
                {drainMetrics.map((metric) => (
                  <div
                    key={metric.drainType}
                    className={`${DRAIN_COLORS[metric.drainType] || DRAIN_COLORS.unset} transition-all opacity-80 hover:opacity-100`}
                    style={{ width: `${metric.percentage}%` }}
                  />
                ))}
              </div>
              <div className="grid grid-cols-2 gap-3">
                {drainMetrics.map((metric) => {
                  const DrainIcon = DRAIN_ICONS[metric.drainType];
                  return (
                    <div key={metric.drainType} className="flex items-center gap-2 p-2 rounded-lg bg-white/5 border border-white/5">
                      <div className={`w-2 h-2 rounded-full ${DRAIN_COLORS[metric.drainType] || DRAIN_COLORS.unset}`} />
                      {DrainIcon && <DrainIcon className="h-3 w-3 text-muted-foreground" />}
                      <div className="flex-1 min-w-0">
                        <div className="text-xs font-medium truncate text-white/90 capitalize">
                          {metric.drainType}
                        </div>
                        <div className="text-[10px] text-muted-foreground">
                          {metric.count} moves
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : <p className="text-muted-foreground text-sm">No completed moves yet</p>}
        </div>
      </ArcCard>

      {/* Client Activity List */}
      <ArcCard glowColor="none" className="w-full">
        <div className="p-5 sm:p-6">
          <div className="text-lg font-semibold flex items-center gap-2 text-white pb-4">
            <Users className="h-5 w-5 text-white/70" />
            Client Activity
          </div>
          
          {loadingClients ? (
            <div className="space-y-3"><Skeleton className="h-16 w-full bg-white/5" /></div>
          ) : clientMetrics && clientMetrics.length > 0 ? (
            <div className="space-y-3">
              {clientMetrics.map((client) => (
                <div key={client.clientName} className="p-4 rounded-xl bg-white/5 border border-white/5 space-y-3 hover:bg-white/[0.07]">
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <div className="flex items-center gap-3">
                      <span className="font-bold text-white tracking-wide capitalize">{client.clientName}</span>
                      <span className="text-xs text-muted-foreground">{client.totalMoves} moves</span>
                    </div>
                    {client.daysSinceLastMove >= 2 ? (
                      <span className="text-[10px] font-bold text-rose-400 bg-rose-400/10 px-2 py-0.5 rounded-full border border-rose-400/20 uppercase">Stale</span>
                    ) : (
                      <span className="text-[10px] font-bold text-emerald-400 bg-emerald-400/10 px-2 py-0.5 rounded-full border border-emerald-400/20 uppercase">Active</span>
                    )}
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2 pt-2 border-t border-white/5">
                    <Select value={client.sentiment} onValueChange={(val) => updateSentiment.mutate({ clientName: client.clientName, sentiment: val })}>
                        <SelectTrigger className="h-8 text-xs bg-black/20 border-white/10 text-white"><SelectValue /></SelectTrigger>
                        <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                            <SelectItem value="positive">Positive</SelectItem>
                            <SelectItem value="neutral">Neutral</SelectItem>
                            <SelectItem value="negative">Negative</SelectItem>
                        </SelectContent>
                    </Select>
                    <Select value={client.importance} onValueChange={(val) => updateImportance.mutate({ clientName: client.clientName, importance: val })}>
                        <SelectTrigger className="h-8 text-xs bg-black/20 border-white/10 text-white"><SelectValue /></SelectTrigger>
                        <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                            <SelectItem value="high">High Priority</SelectItem>
                            <SelectItem value="medium">Medium</SelectItem>
                            <SelectItem value="low">Low</SelectItem>
                        </SelectContent>
                    </Select>
                  </div>
                </div>
              ))}
            </div>
          ) : <p className="text-muted-foreground text-sm">No client data</p>}
        </div>
      </ArcCard>

      {/* Backlog Health */}
      <ArcCard glowColor="none">
        <div className="p-6">
          <div className="text-lg font-semibold flex items-center gap-2 text-white pb-4">
            <Archive className="h-5 w-5 text-white/70" />
            Backlog Health
          </div>
          {loadingBacklog ? (
            <Skeleton className="h-20 w-full bg-white/5" />
          ) : backlogHealth && backlogHealth.length > 0 ? (
            <div className="space-y-2">
              {backlogHealth.map((client) => (
                <div key={client.clientName} className="flex items-center justify-between p-3 rounded-lg bg-white/5 border border-white/5">
                  <div className="flex flex-col">
                    <span className="font-medium text-white/90 capitalize">{client.clientName}</span>
                    <span className="text-xs text-muted-foreground">{client.totalCount} tasks â€¢ avg {client.avgDays}d old</span>
                  </div>
                  {client.agingCount > 0 ? (
                    <Badge variant="destructive" className="bg-rose-500/20 text-rose-300 border-rose-500/30 hover:bg-rose-500/30">
                      {client.agingCount} aging
                    </Badge>
                  ) : (
                    <Badge className="bg-emerald-500/20 text-emerald-300 border-emerald-500/30 hover:bg-emerald-500/30">
                      Healthy
                    </Badge>
                  )}
                </div>
              ))}
            </div>
          ) : <p className="text-muted-foreground text-sm">No backlog data yet</p>}
        </div>
      </ArcCard>

    </div>
  );

  return (
    <>
      {/* MOBILE VIEW */}
      <div className="h-screen flex md:hidden flex-col bg-[#030309] text-foreground font-sans overflow-hidden">
        <header className="h-14 glass-strong border-b border-purple-500/20 flex items-center justify-between px-4 shrink-0 z-50">
          <div className="absolute bottom-0 left-0 right-0 h-px bg-gradient-to-r from-transparent via-cyan-500/50 to-transparent" />
          <h1 className="text-lg font-display font-semibold tracking-wider text-gradient-purple">Metrics</h1>
          <div className="flex items-center gap-1">
             <Link href="/"><Button variant="ghost" size="icon" className="hover:bg-purple-500/10 text-muted-foreground"><MessageSquare className="h-5 w-5" /></Button></Link>
             <Link href="/moves"><Button variant="ghost" size="icon" className="hover:bg-purple-500/10 text-muted-foreground"><List className="h-5 w-5" /></Button></Link>
             <Button variant="ghost" size="icon" className="hover:bg-cyan-500/10 text-cyan-400"><BarChart3 className="h-5 w-5" /></Button>
          </div>
        </header>

        <ScrollArea className="flex-1">
           <div className="p-4 pb-20 w-full">
              {MetricsContent}
           </div>
        </ScrollArea>
      </div>

      {/* DESKTOP VIEW */}
      <div className="h-screen hidden md:flex bg-transparent text-foreground font-sans">
        <GlassSidebar onTriageClick={() => setTriageOpen(true)} />
        <IslandLayout>
          <div className="h-full flex flex-col">
            <div className="flex items-center justify-between px-6 py-4 border-b border-white/5">
              <div>
                <h2 className="text-lg font-semibold text-white">Metrics</h2>
                <p className="text-sm text-muted-foreground">Track your work pacing and client activity</p>
              </div>
            </div>
            <ScrollArea className="flex-1">
              <div className="max-w-4xl mx-auto px-6 py-6">
                {MetricsContent}
              </div>
            </ScrollArea>
          </div>
        </IslandLayout>
      </div>

      <TriageDialog open={triageOpen} onOpenChange={setTriageOpen} />
    </>
  );
}

