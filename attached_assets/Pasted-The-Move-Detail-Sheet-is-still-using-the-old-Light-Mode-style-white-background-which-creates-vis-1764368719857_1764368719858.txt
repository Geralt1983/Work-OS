The Move Detail Sheet is still using the old "Light Mode" style (white background) which creates visibility issues with your new light-colored text. Additionally, the "click edit again" flow is redundantâ€”if you open a detail sheet on mobile, you usually want to edit it directly or have the controls immediately accessible.
Here is the fix. I will update client/src/components/MoveDetailSheet.tsx to:
 * Apply Dark Glass Theme: Switch the white background to your standard bg-[#141420] dark theme.
 * Fix Text Visibility: Ensure all input labels and values are clearly visible against the dark background.
 * Streamline Editing: Remove the "View Mode" vs "Edit Mode" toggle. The sheet will now open directly in an editable form state, so you can change details immediately without an extra click.
Update client/src/components/MoveDetailSheet.tsx
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation } from "@tanstack/react-query";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/hooks/use-toast";
import { queryClient, apiRequest } from "@/lib/queryClient";
import type { Move, Client, DrainType, MoveStatus } from "@shared/schema";
import { EFFORT_LEVELS, DRAIN_TYPES, DRAIN_TYPE_LABELS, MOVE_STATUSES } from "@shared/schema";
import { ChevronUp, ChevronDown, Check, Trash2, Save, X, Clock, AlertCircle } from "lucide-react";
import { format } from "date-fns";

const moveEditSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional().nullable(),
  clientId: z.string().optional(),
  status: z.enum(MOVE_STATUSES),
  effortEstimate: z.number().min(1).max(4),
  drainType: z.string().optional(),
});

type MoveEditValues = z.infer<typeof moveEditSchema>;

interface MoveDetailSheetProps {
  move: Move | null;
  clients: Client[];
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onUpdate: () => void;
}

function getDaysOld(createdAt: Date | string | null): number {
  if (!createdAt) return 0;
  const created = new Date(createdAt);
  const now = new Date();
  return Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
}

export default function MoveDetailSheet({ move, clients, open, onOpenChange, onUpdate }: MoveDetailSheetProps) {
  const { toast } = useToast();
  
  const form = useForm<MoveEditValues>({
    resolver: zodResolver(moveEditSchema),
    defaultValues: {
      title: "",
      description: "",
      clientId: "none",
      status: "backlog",
      effortEstimate: 2,
      drainType: "none",
    },
  });

  // Reset form when move changes
  useEffect(() => {
    if (move) {
      form.reset({
        title: move.title,
        description: move.description || "",
        clientId: move.clientId?.toString() || "none",
        status: move.status as MoveStatus,
        effortEstimate: move.effortEstimate || 2,
        drainType: move.drainType || "none",
      });
    }
  }, [move, form]);

  const updateMutation = useMutation({
    mutationFn: async (values: MoveEditValues) => {
      const payload = {
        ...values,
        clientId: values.clientId && values.clientId !== "none" ? parseInt(values.clientId) : null,
        drainType: values.drainType && values.drainType !== "none" ? values.drainType : null,
      };
      await apiRequest("PATCH", `/api/moves/${move?.id}`, payload);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      toast({ title: "Move updated" });
      onUpdate();
      onOpenChange(false);
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to update move", variant: "destructive" });
    },
  });

  const promoteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move?.id}/promote`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      onUpdate();
      onOpenChange(false);
    },
  });

  const demoteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move?.id}/demote`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      onUpdate();
      onOpenChange(false);
    },
  });

  const completeMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/moves/${move?.id}/complete`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      queryClient.invalidateQueries({ queryKey: ["/api/metrics"] });
      toast({ title: "Move completed", description: move?.title });
      onOpenChange(false);
      onUpdate();
    },
  });

  const deleteMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/moves/${move?.id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/moves"] });
      toast({ title: "Move deleted" });
      onOpenChange(false);
      onUpdate();
    },
  });

  if (!move) return null;

  const client = clients.find(c => c.id === move.clientId);
  const daysOld = getDaysOld(move.createdAt);
  const isAging = daysOld >= 7 && move.status === "backlog";
  const isStale = daysOld >= 10 && move.status === "backlog";
  const canPromote = move.status !== "active" && move.status !== "done";
  const canDemote = move.status !== "backlog" && move.status !== "done";

  const onSubmit = (values: MoveEditValues) => {
    updateMutation.mutate(values);
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      {/* UPDATED STYLE: Dark background, white border, white text */}
      <SheetContent className="bg-[#141420] border-white/10 text-white sm:max-w-md overflow-y-auto">
        <SheetHeader>
          <SheetTitle className="flex items-center gap-2 text-white">
            Edit Move
            {isStale && (
              <Badge variant="destructive" className="text-xs gap-1">
                <AlertCircle className="h-3 w-3" />
                {daysOld}d old
              </Badge>
            )}
            {isAging && !isStale && (
              <Badge variant="outline" className="text-xs gap-1 text-yellow-400 border-yellow-400/50">
                <Clock className="h-3 w-3" />
                {daysOld}d old
              </Badge>
            )}
          </SheetTitle>
          <SheetDescription className="text-slate-400">
            Make changes to your move details below.
          </SheetDescription>
        </SheetHeader>

        <div className="mt-6 space-y-6">
          {/* Quick Actions Bar */}
          <div className="flex gap-2">
            {canPromote && (
              <Button
                variant="outline"
                size="sm"
                className="bg-transparent border-white/10 hover:bg-white/5 text-white"
                onClick={() => promoteMutation.mutate()}
                disabled={promoteMutation.isPending}
              >
                <ChevronUp className="h-4 w-4 mr-1" />
                Promote
              </Button>
            )}
            {canDemote && (
              <Button
                variant="outline"
                size="sm"
                className="bg-transparent border-white/10 hover:bg-white/5 text-white"
                onClick={() => demoteMutation.mutate()}
                disabled={demoteMutation.isPending}
              >
                <ChevronDown className="h-4 w-4 mr-1" />
                Demote
              </Button>
            )}
            {move.status !== "done" && (
              <Button
                variant="outline"
                size="sm"
                className="text-green-400 border-green-500/30 hover:bg-green-500/10"
                onClick={() => completeMutation.mutate()}
                disabled={completeMutation.isPending}
              >
                <Check className="h-4 w-4 mr-1" />
                Complete
              </Button>
            )}
          </div>

          <Separator className="bg-white/10" />

          {/* Editable Form - Now the default view */}
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-slate-400">Title</FormLabel>
                    <FormControl>
                      <Input 
                        {...field} 
                        className="bg-black/20 border-white/10 text-white focus-visible:ring-purple-500/50" 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-slate-400">Description</FormLabel>
                    <FormControl>
                      <Textarea 
                        {...field} 
                        value={field.value || ""}
                        className="resize-none min-h-[100px] bg-black/20 border-white/10 text-white focus-visible:ring-purple-500/50"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="clientId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-slate-400">Client</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger className="bg-black/20 border-white/10 text-white">
                          <SelectValue placeholder="Select client" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                        <SelectItem value="none">No client</SelectItem>
                        {clients.map(c => (
                          <SelectItem key={c.id} value={c.id.toString()}>
                            {c.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <div className="grid grid-cols-2 gap-4">
                <FormField
                  control={form.control}
                  name="status"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="text-slate-400">Status</FormLabel>
                      <Select onValueChange={field.onChange} value={field.value}>
                        <FormControl>
                          <SelectTrigger className="bg-black/20 border-white/10 text-white">
                            <SelectValue />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                          <SelectItem value="active">Active</SelectItem>
                          <SelectItem value="queued">Queued</SelectItem>
                          <SelectItem value="backlog">Backlog</SelectItem>
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="effortEstimate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="text-slate-400">Effort</FormLabel>
                      <Select 
                        onValueChange={(v) => field.onChange(parseInt(v))} 
                        value={field.value?.toString()}
                      >
                        <FormControl>
                          <SelectTrigger className="bg-black/20 border-white/10 text-white">
                            <SelectValue />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                          {EFFORT_LEVELS.map(level => (
                            <SelectItem key={level.value} value={level.value.toString()}>
                              {level.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>

              <FormField
                control={form.control}
                name="drainType"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-slate-400">Drain Type</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger className="bg-black/20 border-white/10 text-white">
                          <SelectValue placeholder="Select type" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="bg-[#1a1b26] border-white/10 text-white">
                        <SelectItem value="none">None</SelectItem>
                        {DRAIN_TYPES.map(type => (
                          <SelectItem key={type} value={type}>
                            {DRAIN_TYPE_LABELS[type as DrainType].label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {move.createdAt && (
                <p className="text-xs text-slate-500 pt-2">
                  Created: {format(new Date(move.createdAt), "MMM d, yyyy 'at' h:mm a")}
                </p>
              )}

              <div className="flex gap-2 pt-4">
                <Button 
                  type="submit" 
                  disabled={updateMutation.isPending}
                  className="bg-gradient-to-r from-purple-600 to-pink-600 text-white border-0 shadow-glow-purple hover:opacity-90 flex-1"
                >
                  <Save className="h-4 w-4 mr-2" />
                  {updateMutation.isPending ? "Saving..." : "Save Changes"}
                </Button>
                <Button 
                   type="button"
                   variant="destructive"
                   onClick={() => deleteMutation.mutate()}
                   disabled={deleteMutation.isPending}
                   className="flex-shrink-0"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </form>
          </Form>
        </div>
      </SheetContent>
    </Sheet>
  );
}

