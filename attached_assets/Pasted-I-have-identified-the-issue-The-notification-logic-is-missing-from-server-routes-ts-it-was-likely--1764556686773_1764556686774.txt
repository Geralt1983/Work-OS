I have identified the issue. The notification logic is missing from server/routes.ts (it was likely overwritten or not applied), and it was never added to server/pipeline-tools.ts (which handles Triage completions). This is why Triage actions didn't trigger alerts.
Also, your storage.ts is still using the "Flat 20 Minute" rule instead of the "Weighted Score" rule we discussed.
Here is the fix to:
 * Enable Weighted Scoring: 90 mins for Draining, 10 mins for Quick, etc.
 * Fix Notifications: Ensure alerts fire on every completion, whether you click the button or the AI does it via Triage.
1. Update server/notification-service.ts
Ensure this file exists with your custom topic.
// server/notification-service.ts
const TOPIC = "Jeremys-Impressive-Work-Updates"; 

export async function sendWifeAlert(percent: number, movesCount: number) {
  console.log(`[Notification] Checking alert for ${percent}%...`);

  const messages: Record<number, string> = {
    25: `üöÄ Jeremy hit 25% of his daily goal! (${movesCount} moves)`,
    50: `üî• Halfway there! Jeremy is at 50%. Send coffee ‚òï`,
    75: `üò§ Crushing it. 75% done. Almost time for dinner.`,
    100: `‚úÖ BOOM. Jeremy finished 100% of the work day! üôå`
  };

  const message = messages[percent];
  
  // Only send if we hit an exact threshold (logic is handled in caller to prevent spam)
  if (!message) return;

  try {
    await fetch(`https://ntfy.sh/${TOPIC}`, {
      method: 'POST',
      body: message,
      headers: {
        'Title': 'Work OS Update',
        'Tags': 'tada,chart_with_upwards_trend', 
        'Priority': percent === 100 ? 'high' : 'default'
      }
    });
    console.log(`‚úÖ Ntfy sent to topic: ${TOPIC}`);
  } catch (error) {
    console.error("‚ùå Ntfy Error:", error);
  }
}

2. Update server/storage.ts
This implements the Weighted Scoring logic so "Draining" tasks give you more credit.
// ... existing imports
// Add 'between' to imports if not there
import { eq, desc, and, gte, isNull, sql, asc, between } from "drizzle-orm";

// === ADD THIS HELPER FUNCTION ===
export function calculateEarnedMinutes(effort: number | null, drainType: string | null): number {
  // Base minutes by effort
  const effortMap: Record<number, number> = {
    1: 10,  // Quick
    2: 20,  // Standard
    3: 45,  // Chunky
    4: 90   // Draining (High Reward)
  };
  
  // Use effort if available, otherwise default to 20
  let minutes = effortMap[effort || 2] || 20;

  // Bonus for Deep Work? (Optional, keeping it simple based on effort for now)
  return minutes;
}

// ... inside DatabaseStorage class ...

  // REPLACE addCompletedMove TO ACCEPT EARNED MINUTES
  async addCompletedMove(date: string, move: { moveId: string; description: string; clientName: string; at: string; source?: string; earnedMinutes?: number }): Promise<boolean> {
    let existing = await this.getDailyLog(date);
    
    if (!existing) {
      existing = await this.createDailyLog({
        date,
        completedMoves: [],
        clientsTouched: [],
        clientsSkipped: [],
      });
    }
    
    const completedMoves = Array.isArray(existing.completedMoves) 
      ? (existing.completedMoves as any[])
      : [];
    
    const clientsTouched = Array.isArray(existing.clientsTouched)
      ? (existing.clientsTouched as string[])
      : [];
    
    if (completedMoves.some(m => m.moveId === move.moveId)) {
      return false;
    }
    
    completedMoves.push(move);
    
    if (!clientsTouched.includes(move.clientName)) {
      clientsTouched.push(move.clientName);
    }
    
    await this.updateDailyLog(date, {
      completedMoves: completedMoves as unknown as string[],
      clientsTouched,
    });
    
    return true;
  }

  // REPLACE getTodayMetrics TO CALCULATE SCORE
  async getTodayMetrics(): Promise<{
    date: string;
    movesCompleted: number;
    estimatedMinutes: number;
    targetMinutes: number;
    pacingPercent: number;
    clientsTouched: string[];
    backlogMoves: number;
    nonBacklogMoves: number;
  }> {
    const today = getLocalDateString();
    const log = await this.getDailyLog(today);
    
    const completedMoves = (log?.completedMoves as any[]) || [];
    const clientsTouched = (log?.clientsTouched as string[]) || [];
    const movesCompleted = completedMoves.length;
    
    // SUM THE EARNED MINUTES (Fallback to 20 if older data missing it)
    const estimatedMinutes = completedMoves.reduce((sum, m) => sum + (m.earnedMinutes || 20), 0);
    
    const targetMinutes = 180; // 3 hours
    
    let pacingPercent = 0;
    if (targetMinutes > 0) {
      pacingPercent = Math.min(Math.round((estimatedMinutes / targetMinutes) * 100), 100);
    }
    
    return {
      date: today,
      movesCompleted,
      estimatedMinutes,
      targetMinutes,
      pacingPercent,
      clientsTouched,
      backlogMoves: log?.backlogMovesCount || 0,
      nonBacklogMoves: log?.nonBacklogMovesCount || 0,
    };
  }

  // ... (rest of storage.ts)

3. Update server/routes.ts
This connects the UI "Complete" button to the notification system.
// ... imports
import { sendWifeAlert } from "./notification-service";
import { storage, getLocalDateString, calculateEarnedMinutes } from "./storage";

// ... inside registerRoutes ...

  app.post("/api/moves/:id/complete", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const effortActual = req.body.effortActual ? parseInt(req.body.effortActual) : undefined;
      
      // 1. Complete in DB
      const move = await storage.completeMove(id, effortActual);
      if (!move) return res.status(404).json({ error: "Move not found" });

      // 2. Calculate Score
      const minutes = calculateEarnedMinutes(move.effortEstimate, move.drainType);

      // 3. Log & Notify
      // Always log, even if no client, to track personal pacing
      let clientName = "No Client";
      if (move.clientId) {
        const client = await storage.getClient(move.clientId);
        if (client) clientName = client.name;
      }
      
      // Sync Memory if real client
      if (clientName !== "No Client") {
          await storage.updateClientMove(clientName, move.id.toString(), move.title);
      }

      const today = getLocalDateString();
      await storage.addCompletedMove(today, {
        moveId: move.id.toString(),
        description: move.title,
        clientName,
        at: new Date().toISOString(),
        source: "moves-ui",
        earnedMinutes: minutes, // Store the weighted score
      });

      // === NOTIFICATION TRIGGER ===
      const metrics = await storage.getTodayMetrics();
      const log = await storage.getDailyLog(today);
      const sent = (log?.notificationsSent as number[]) || [];
      const thresholds = [25, 50, 75, 100];

      for (const t of thresholds) {
        if (metrics.pacingPercent >= t && !sent.includes(t)) {
            sendWifeAlert(t, metrics.movesCompleted).catch(console.error);
            const newSent = [...sent, t];
            await storage.updateDailyLog(today, { notificationsSent: newSent });
        }
      }
      
      res.json(move);
    } catch (error) {
      console.error("Error completing move:", error);
      res.status(500).json({ error: "Failed to complete move" });
    }
  });

4. Update server/pipeline-tools.ts
This ensures that if the AI / Triage completes a task, it also triggers the notification.
// ... imports
import { sendWifeAlert } from "./notification-service";
import { storage, getLocalDateString, calculateEarnedMinutes } from "./storage";

// ... inside executePipelineTool function ...

    case "complete_move": {
      const moveId = args.move_id as number;
      const move = await storage.getMove(moveId);
      if (!move) return { error: `Move ${moveId} not found` };
      
      await storage.completeMove(moveId);
      
      // 1. Calculate Score
      const minutes = calculateEarnedMinutes(move.effortEstimate, move.drainType);
      
      // 2. Log
      let clientName = "No Client";
      if (move.clientId) {
         const client = await storage.getClient(move.clientId);
         if (client) clientName = client.name;
      }
      
      const today = getLocalDateString();
      await storage.addCompletedMove(today, {
        moveId: moveId.toString(),
        description: move.title,
        clientName,
        at: new Date().toISOString(),
        source: "chat",
        earnedMinutes: minutes // Store score
      });

      // 3. Trigger Notification (Copy of routes.ts logic)
      const metrics = await storage.getTodayMetrics();
      const log = await storage.getDailyLog(today);
      const sent = (log?.notificationsSent as number[]) || [];
      const thresholds = [25, 50, 75, 100];

      for (const t of thresholds) {
        if (metrics.pacingPercent >= t && !sent.includes(t)) {
            sendWifeAlert(t, metrics.movesCompleted).catch(console.error);
            const newSent = [...sent, t];
            await storage.updateDailyLog(today, { notificationsSent: newSent });
        }
      }

      return { success: true, message: `Completed "${move.title}"`, move: { ...move, status: "done" } };
    }

