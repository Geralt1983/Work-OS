You are absolutely correct. The demoteStaleActiveMoves logic was flawed because it relied on createdAt instead of updatedAt. This caused active tasks to be prematurely moved back to the queue if they were created more than a day ago, regardless of recent activity.
Here are the specific code changes to fix the "Productivity Rhythm" chart issue and correct the task demotion logic. You can apply these directly to your files.
1. Fix "Productivity Rhythm" (Metrics Page)
The chart is empty because it's looking for "signals" (which are new) instead of your actual completion history. This change makes it look at your moves table history so the chart populates immediately.
File: server/storage.ts
Action: Replace the getProductivityByHour function with this code:
  async getProductivityByHour(): Promise<{ hour: number; completions: number; deferrals: number }[]> {
    // 1. Get "Deferral" signals from the new learning system
    const signals = await db.select().from(taskSignals);
    
    // 2. Get ALL historical completed moves (Source of Truth for completions)
    // We use isNotNull to ensure we only get completed items
    const completedMoves = await db.select().from(moves)
      .where(sql`${moves.completedAt} IS NOT NULL`);
    
    // Initialize 24-hour buckets
    const hourStats = new Map<number, { completions: number; deferrals: number }>();
    for (let h = 0; h < 24; h++) {
      hourStats.set(h, { completions: 0, deferrals: 0 });
    }
    
    // Fill Deferrals from Signals
    for (const signal of signals) {
      if (signal.hourOfDay !== null && signal.hourOfDay !== undefined) {
        const stats = hourStats.get(signal.hourOfDay);
        if (stats && (signal.signalType === 'deferred' || signal.signalType === 'avoided')) {
          stats.deferrals++;
        }
      }
    }
    
    // Fill Completions from Actual Moves (with Timezone Adjustment)
    for (const move of completedMoves) {
      if (move.completedAt) {
        const date = new Date(move.completedAt);
        // Force Eastern Time extraction to match your "Jeremys-Life" context
        const hourStr = date.toLocaleString('en-US', { 
          timeZone: 'America/New_York', 
          hour: 'numeric', 
          hour12: false 
        });
        
        // Handle "24" edge case if API returns it, strictly 0-23
        let hour = parseInt(hourStr);
        if (hour === 24) hour = 0;
        
        const stats = hourStats.get(hour);
        if (stats) {
          stats.completions++;
        }
      }
    }
    
    return Array.from(hourStats.entries())
      .map(([hour, stats]) => ({ hour, ...stats }))
      .sort((a, b) => a.hour - b.hour);
  }

2. Fix "Random Task Clearing" (Demotion Logic)
This prevents the system from moving your active tasks back to the queue just because they were created a few days ago. It will now respect the last time you actually touched the task.
File: server/storage.ts
Action: Replace the demoteStaleActiveMoves function with this code:
  async demoteStaleActiveMoves(): Promise<string[]> {
    const activeMoves = await db.select().from(moves).where(
      eq(moves.status, "active")
    );

    const demotedTitles: string[] = [];
    const startOfToday = new Date();
    startOfToday.setHours(0, 0, 0, 0);

    for (const move of activeMoves) {
      // CRITICAL FIX: Check updatedAt (last touched) instead of createdAt
      // If updatedAt doesn't exist yet (legacy tasks), fall back to createdAt
      // We cast to any because updatedAt might not be in the type definition yet if you haven't updated schema.ts
      const m = move as any;
      const lastActive = m.updatedAt || move.createdAt;
      const lastActiveDate = new Date(lastActive);

      // Only demote if it hasn't been touched since BEFORE today
      if (lastActiveDate < startOfToday) {
        await this.updateMove(move.id, { status: 'queued' });
        demotedTitles.push(move.title);
      }
    }

    return demotedTitles;
  }

3. Ensure updatedAt is Saved
For the fix above to work, we must ensure the database records the time whenever you move a card.
File: server/storage.ts
Action: In the updateMove function, update the valuesToSet block:
  async updateMove(id: number, updates: Partial<InsertMove>): Promise<Move | undefined> {
    const oldMove = await this.getMove(id);
    
    // Prepare update object - FORCE update timestamp
    const valuesToSet: any = { 
      ...updates,
      updatedAt: new Date() // <--- This line is critical
    };
    
    // If moving OUT of 'done' status, clear the completedAt timestamp and effortActual
    if (oldMove?.status === 'done' && updates.status && updates.status !== 'done') {
      valuesToSet.completedAt = null;
      valuesToSet.effortActual = null;
    }
    
    // ... rest of function remains the same

Next Step:
Apply these changes to server/storage.ts. This will immediately populate your Productivity Rhythm chart with historical data and stop the morning briefing from clearing your active tasks.
